pu	8baf22419dc97d8b148f005bc3cf1dbf6f5cc72d
jch	17aadd8971c6116e923cb31fab6a23399a960a05
next	a6e4e5af0a9b9658e3add26e39643dac049beff2
master	d9f6f3b6195a0ca35642561e530798ad1469bd41
master@{1}	v2.24.0


Uncovered code in 'pu' not in 'jch'
--------------------------------------------------------

Commits introducting uncovered code:
Jonathan Nieder	ee70c128 index: offer advice for unknown index extensions
read-cache.c
ee70c128 1745) if (advice_unknown_index_extension) {

Josh Steadmon	6da1f1a9 protocol: advertise multiple supported versions
remote-curl.c
6da1f1a9 354) return 0;

Matheus Tavares	beebb9d2 object-store: allow threaded access to object reading
packfile.c
beebb9d2 1464) return;

sha1-file.c
beebb9d2 1431) return;
beebb9d2 1440) return;



Uncovered code in 'jch' not in 'next'
--------------------------------------------------------

Commits introducting uncovered code:
Daniel Ferreira	5e82b9e4 built-in add -i: implement the `status` command
add-interactive.c
5e82b9e4 626) return -1;
5e82b9e4 629) putchar('\n');
5e82b9e4 631) return 0;

Johannes Schindelin	0de7b036 built-in add -i: offer the `quit` command
add-interactive.c
0de7b036 1126) if (i < 0 || i >= commands.items.nr)
0de7b036 1127) util = NULL;
0de7b036 1129) util = commands.items.items[i].util;
0de7b036 1131) if (i == LIST_AND_CHOOSE_QUIT || (util && !util->command)) {
0de7b036 1137) if (util)

Johannes Schindelin	465a9699 built-in add -i: re-implement the `diff` command
add-interactive.c
465a9699 931) static int run_diff(struct add_i_state *s, const struct pathspec *ps,
465a9699 935) int res = 0;
465a9699 939) int is_initial = !resolve_ref_unsafe("HEAD", RESOLVE_REF_READING, &oid,
465a9699 941) if (get_modified_files(s->r, INDEX_ONLY, files, ps, NULL, NULL) < 0)
465a9699 942) return -1;
465a9699 944) if (!files->items.nr) {
465a9699 945) putchar('\n');
465a9699 946) return 0;
465a9699 949) opts->prompt = N_("Review diff");
465a9699 950) opts->flags = IMMEDIATE;
465a9699 951) count = list_and_choose(s, files, opts);
465a9699 952) opts->flags = 0;
465a9699 953) if (count >= 0) {
465a9699 954) struct argv_array args = ARGV_ARRAY_INIT;
465a9699 956) argv_array_pushl(&args, "git", "diff", "-p", "--cached",
465a9699 958)     s->r->hash_algo->empty_tree),
465a9699 960) for (i = 0; i < files->items.nr; i++)
465a9699 961) if (files->selected[i])
465a9699 962) argv_array_push(&args,
465a9699 963) files->items.items[i].string);
465a9699 964) res = run_command_v_opt(args.argv, 0);
465a9699 965) argv_array_clear(&args);
465a9699 968) putchar('\n');
465a9699 969) return res;

Johannes Schindelin	116a408b commit: give correct advice for empty commit during a rebase
builtin/commit.c
116a408b 478) else if (whence == FROM_CHERRY_PICK) {
116a408b 479) if (rebase_in_progress && !sequencer_in_use)
116a408b 1186) else if (whence == FROM_CHERRY_PICK) {
116a408b 1187) if (rebase_in_progress && !sequencer_in_use)

Johannes Schindelin	daabf56b built-in add -i: re-implement `add-untracked` in C
add-interactive.c
daabf56b 606) if (d->only_names) {
daabf56b 607) printf("%c%2d: %s", selected ? '*' : ' ', i + 1,
daabf56b 609) return;
daabf56b 791) static int get_untracked_files(struct repository *r,
daabf56b 795) struct dir_struct dir = { 0 };
daabf56b 797) struct strbuf buf = STRBUF_INIT;
daabf56b 799) if (repo_read_index(r) < 0)
daabf56b 802) prefix_item_list_clear(files);
daabf56b 803) setup_standard_excludes(&dir);
daabf56b 804) add_pattern_list(&dir, EXC_CMDL, "--exclude option");
daabf56b 805) fill_directory(&dir, r->index, ps);
daabf56b 807) for (i = 0; i < dir.nr; i++) {
daabf56b 808) struct dir_entry *ent = dir.entries[i];
daabf56b 810) if (index_name_is_other(r->index, ent->name, ent->len)) {
daabf56b 811) strbuf_reset(&buf);
daabf56b 812) strbuf_add(&buf, ent->name, ent->len);
daabf56b 813) add_file_item(&files->items, buf.buf);
daabf56b 817) strbuf_release(&buf);
daabf56b 821) static int run_add_untracked(struct add_i_state *s, const struct pathspec *ps,
daabf56b 825) struct print_file_item_data *d = opts->list_opts.print_item_data;
daabf56b 826) int res = 0, fd;
daabf56b 830) if (get_untracked_files(s->r, files, ps) < 0)
daabf56b 831) return -1;
daabf56b 833) if (!files->items.nr) {
daabf56b 834) printf(_("No untracked files.\n"));
daabf56b 835) goto finish_add_untracked;
daabf56b 838) opts->prompt = N_("Add untracked");
daabf56b 839) d->only_names = 1;
daabf56b 840) count = list_and_choose(s, files, opts);
daabf56b 841) d->only_names = 0;
daabf56b 842) if (count <= 0)
daabf56b 843) goto finish_add_untracked;
daabf56b 845) fd = repo_hold_locked_index(s->r, &index_lock, LOCK_REPORT_ON_ERROR);
daabf56b 846) if (fd < 0) {
daabf56b 847) res = -1;
daabf56b 848) goto finish_add_untracked;
daabf56b 851) for (i = 0; i < files->items.nr; i++) {
daabf56b 852) const char *name = files->items.items[i].string;
daabf56b 853) if (files->selected[i] &&
daabf56b 854)     add_file_to_index(s->r->index, name, 0) < 0) {
daabf56b 856) break;
daabf56b 860) if (!res &&
daabf56b 861)     write_locked_index(s->r->index, &index_lock, COMMIT_LOCK) < 0)
daabf56b 864) if (!res)
daabf56b 865) printf(Q_("added %d path\n",
daabf56b 869) putchar('\n');
daabf56b 870) return res;

Johannes Schindelin	4ba7c22a built-in add -i: implement the `update` command
add-interactive.c
4ba7c22a 504) prefix_item_list_clear(files);
4ba7c22a 505) s.files = &files->items;
4ba7c22a 545) string_list_sort(&files->items);
4ba7c22a 590) const char *highlighted = NULL;
4ba7c22a 597) if (c->prefix_length > 0 &&
4ba7c22a 598)     is_valid_prefix(item->string, c->prefix_length)) {
4ba7c22a 599) strbuf_reset(&d->name);
4ba7c22a 600) strbuf_addf(&d->name, "%s%.*s%s%s", d->color,
4ba7c22a 601)     (int)c->prefix_length, item->string, d->reset,
4ba7c22a 602)     item->string + c->prefix_length);
4ba7c22a 603) highlighted = d->name.buf;
4ba7c22a 615) strbuf_addf(&d->buf, d->modified_fmt, d->index.buf, d->worktree.buf,
4ba7c22a 628) list(s, &files->items, NULL, &opts->list_opts);
4ba7c22a 634) static int run_update(struct add_i_state *s, const struct pathspec *ps,
4ba7c22a 638) int res = 0, fd;
4ba7c22a 643) return -1;
4ba7c22a 645) if (!files->items.nr) {
4ba7c22a 646) putchar('\n');
4ba7c22a 647) return 0;
4ba7c22a 650) opts->prompt = N_("Update");
4ba7c22a 651) count = list_and_choose(s, files, opts);
4ba7c22a 652) if (count <= 0) {
4ba7c22a 653) putchar('\n');
4ba7c22a 654) return 0;
4ba7c22a 657) fd = repo_hold_locked_index(s->r, &index_lock, LOCK_REPORT_ON_ERROR);
4ba7c22a 658) if (fd < 0) {
4ba7c22a 659) putchar('\n');
4ba7c22a 660) return -1;
4ba7c22a 663) for (i = 0; i < files->items.nr; i++) {
4ba7c22a 664) const char *name = files->items.items[i].string;
4ba7c22a 665) if (files->selected[i] &&
4ba7c22a 666)     add_file_to_index(s->r->index, name, 0) < 0) {
4ba7c22a 668) break;
4ba7c22a 672) if (!res && write_locked_index(s->r->index, &index_lock, COMMIT_LOCK) < 0)
4ba7c22a 675) if (!res)
4ba7c22a 676) printf(Q_("updated %d path\n",
4ba7c22a 679) putchar('\n');
4ba7c22a 680) return res;
4ba7c22a 992) static void choose_prompt_help(struct add_i_state *s)
4ba7c22a 994) color_fprintf_ln(stdout, s->help_color, "%s",
4ba7c22a 996) color_fprintf_ln(stdout, s->help_color, "1          - %s",
4ba7c22a 998) color_fprintf_ln(stdout, s->help_color, "3-5        - %s",
4ba7c22a 1000) color_fprintf_ln(stdout, s->help_color, "2-3,6-9    - %s",
4ba7c22a 1002) color_fprintf_ln(stdout, s->help_color, "foo        - %s",
4ba7c22a 1004) color_fprintf_ln(stdout, s->help_color, "-...       - %s",
4ba7c22a 1006) color_fprintf_ln(stdout, s->help_color, "*          - %s",
4ba7c22a 1008) color_fprintf_ln(stdout, s->help_color, "           - %s",
4ba7c22a 1010) }
4ba7c22a 1080) struct list_and_choose_options opts = {
4ba7c22a 1085) struct prefix_item_list files = PREFIX_ITEM_LIST_INIT;
4ba7c22a 1106) print_file_item_data.color = data.color;
4ba7c22a 1107) print_file_item_data.reset = data.reset;
4ba7c22a 1112) opts.list_opts.header = header.buf;
4ba7c22a 1141) prefix_item_list_clear(&files);
4ba7c22a 1143) strbuf_release(&print_file_item_data.name);

Johannes Schindelin	9d86921e built-in add -i: implement the `patch` command
add-interactive.c
9d86921e 462) other_adddel = s->phase == FROM_INDEX ?
9d86921e 463) &file_item->worktree : &file_item->index;
9d86921e 467) if (stat.files[i]->is_binary) {
9d86921e 468) if (!other_adddel->binary)
9d86921e 469) s->binary_count++;
9d86921e 472) if (stat.files[i]->is_unmerged) {
9d86921e 473) if (!other_adddel->unmerged)
9d86921e 474) s->unmerged_count++;
9d86921e 475) adddel->unmerged = 1;
9d86921e 539) if (unmerged_count)
9d86921e 540) *unmerged_count = s.unmerged_count;
9d86921e 541) if (binary_count)
9d86921e 542) *binary_count = s.binary_count;
9d86921e 625) if (get_modified_files(s->r, NO_FILTER, files, ps, NULL, NULL) < 0)
9d86921e 642) if (get_modified_files(s->r, WORKTREE_ONLY, files, ps, NULL, NULL) < 0)
9d86921e 721) if (get_modified_files(s->r, INDEX_ONLY, files, ps, NULL, NULL) < 0)
9d86921e 873) static int run_patch(struct add_i_state *s, const struct pathspec *ps,
9d86921e 877) int res = 0;
9d86921e 879) size_t unmerged_count = 0, binary_count = 0;
9d86921e 881) if (get_modified_files(s->r, WORKTREE_ONLY, files, ps,
9d86921e 883) return -1;
9d86921e 885) if (unmerged_count || binary_count) {
9d86921e 886) for (i = j = 0; i < files->items.nr; i++) {
9d86921e 887) struct file_item *item = files->items.items[i].util;
9d86921e 889) if (item->index.binary || item->worktree.binary) {
9d86921e 890) free(item);
9d86921e 891) free(files->items.items[i].string);
9d86921e 892) } else if (item->index.unmerged ||
9d86921e 894) color_fprintf_ln(stderr, s->error_color,
9d86921e 896)  files->items.items[i].string);
9d86921e 897) free(item);
9d86921e 898) free(files->items.items[i].string);
9d86921e 900) files->items.items[j++] = files->items.items[i];
9d86921e 902) files->items.nr = j;
9d86921e 905) if (!files->items.nr) {
9d86921e 906) if (binary_count)
9d86921e 907) fprintf(stderr, _("Only binary files changed.\n"));
9d86921e 909) fprintf(stderr, _("No changes.\n"));
9d86921e 910) return 0;
9d86921e 913) opts->prompt = N_("Patch update");
9d86921e 914) count = list_and_choose(s, files, opts);
9d86921e 915) if (count >= 0) {
9d86921e 916) struct argv_array args = ARGV_ARRAY_INIT;
9d86921e 918) argv_array_pushl(&args, "git", "add--interactive", "--patch",
9d86921e 920) for (i = 0; i < files->items.nr; i++)
9d86921e 921) if (files->selected[i])
9d86921e 922) argv_array_push(&args,
9d86921e 923) files->items.items[i].string);
9d86921e 924) res = run_command_v_opt(args.argv, 0);
9d86921e 925) argv_array_clear(&args);
9d86921e 928) return res;

Johannes Schindelin	a5ced6db built-in add -i: allow filtering the modified files list
add-interactive.c
a5ced6db 447) if (s->skip_unseen)
a5ced6db 448) continue;
a5ced6db 487) static int get_modified_files(struct repository *r,
a5ced6db 508) for (i = 0; i < 2; i++) {
a5ced6db 512) if (filter == INDEX_ONLY)
a5ced6db 513) s.phase = i ? FROM_WORKTREE : FROM_INDEX;
a5ced6db 515) s.phase = i ? FROM_INDEX : FROM_WORKTREE;
a5ced6db 516) s.skip_unseen = filter && i;

Johannes Schindelin	dea080c8 built-in add -i: re-implement `revert` in C
add-interactive.c
dea080c8 683) static void revert_from_diff(struct diff_queue_struct *q,
dea080c8 686) int i, add_flags = ADD_CACHE_OK_TO_ADD | ADD_CACHE_OK_TO_REPLACE;
dea080c8 688) for (i = 0; i < q->nr; i++) {
dea080c8 689) struct diff_filespec *one = q->queue[i]->one;
dea080c8 692) if (!(one->mode && !is_null_oid(&one->oid))) {
dea080c8 693) remove_file_from_index(opt->repo->index, one->path);
dea080c8 694) printf(_("note: %s is untracked now.\n"), one->path);
dea080c8 696) ce = make_cache_entry(opt->repo->index, one->mode,
dea080c8 697)       &one->oid, one->path, 0, 0);
dea080c8 698) if (!ce)
dea080c8 701) add_index_entry(opt->repo->index, ce, add_flags);
dea080c8 704) }
dea080c8 706) static int run_revert(struct add_i_state *s, const struct pathspec *ps,
dea080c8 710) int res = 0, fd;
dea080c8 714) int is_initial = !resolve_ref_unsafe("HEAD", RESOLVE_REF_READING, &oid,
dea080c8 719) struct diff_options diffopt = { NULL };
dea080c8 724) if (!files->items.nr) {
dea080c8 725) putchar('\n');
dea080c8 726) return 0;
dea080c8 729) opts->prompt = N_("Revert");
dea080c8 730) count = list_and_choose(s, files, opts);
dea080c8 731) if (count <= 0)
dea080c8 732) goto finish_revert;
dea080c8 734) fd = repo_hold_locked_index(s->r, &index_lock, LOCK_REPORT_ON_ERROR);
dea080c8 735) if (fd < 0) {
dea080c8 736) res = -1;
dea080c8 737) goto finish_revert;
dea080c8 740) if (is_initial)
dea080c8 741) oidcpy(&oid, s->r->hash_algo->empty_tree);
dea080c8 743) tree = parse_tree_indirect(&oid);
dea080c8 744) if (!tree) {
dea080c8 746) goto finish_revert;
dea080c8 748) oidcpy(&oid, &tree->object.oid);
dea080c8 751) ALLOC_ARRAY(paths, count + 1);
dea080c8 752) for (i = j = 0; i < files->items.nr; i++)
dea080c8 753) if (files->selected[i])
dea080c8 754) paths[j++] = files->items.items[i].string;
dea080c8 755) paths[j] = NULL;
dea080c8 757) parse_pathspec(&diffopt.pathspec, 0,
dea080c8 761) diffopt.output_format = DIFF_FORMAT_CALLBACK;
dea080c8 762) diffopt.format_callback = revert_from_diff;
dea080c8 763) diffopt.flags.override_submodule_config = 1;
dea080c8 764) diffopt.repo = s->r;
dea080c8 766) if (do_diff_cache(&oid, &diffopt))
dea080c8 767) res = -1;
dea080c8 769) diffcore_std(&diffopt);
dea080c8 770) diff_flush(&diffopt);
dea080c8 772) free(paths);
dea080c8 773) clear_pathspec(&diffopt.pathspec);
dea080c8 775) if (!res && write_locked_index(s->r->index, &index_lock,
dea080c8 777) res = -1;
dea080c8 779) res = repo_refresh_and_write_index(s->r, REFRESH_QUIET, 0, 1,
dea080c8 782) if (!res)
dea080c8 783) printf(Q_("reverted %d path\n",
dea080c8 788) return res;

Johannes Schindelin	d17e3a76 built-in add -i: prepare for multi-selection commands
add-interactive.c
d17e3a76 88) FREE_AND_NULL(list->selected);
d17e3a76 195) static void list(struct add_i_state *s, struct string_list *list, int *selected,
d17e3a76 208) opts->print_item(i, selected ? selected[i] : 0, list->items + i,
d17e3a76 249) int singleton = opts->flags & SINGLETON;
d17e3a76 250) int immediate = opts->flags & IMMEDIATE;
d17e3a76 253) ssize_t res = singleton ? LIST_AND_CHOOSE_ERROR : 0;
d17e3a76 255) if (!singleton) {
d17e3a76 256) free(items->selected);
d17e3a76 257) CALLOC_ARRAY(items->selected, items->items.nr);
d17e3a76 260) if (singleton && !immediate)
d17e3a76 270) list(s, &items->items, items->selected, &opts->list_opts);
d17e3a76 273) fputs(singleton ? "> " : ">> ", stdout);
d17e3a76 278) if (immediate)
d17e3a76 279) res = LIST_AND_CHOOSE_QUIT;
d17e3a76 295) int choose = 1;
d17e3a76 297) ssize_t from = -1, to = -1;
d17e3a76 307) if (*p == '-') {
d17e3a76 308) choose = 0;
d17e3a76 309) p++;
d17e3a76 310) sep--;
d17e3a76 313) if (sep == 1 && *p == '*') {
d17e3a76 314) from = 0;
d17e3a76 315) to = items->items.nr;
d17e3a76 316) } else if (isdigit(*p)) {
d17e3a76 327) from = strtoul(p, &endp, 10) - 1;
d17e3a76 328) if (endp == p + sep)
d17e3a76 329) to = from + 1;
d17e3a76 330) else if (*endp == '-') {
d17e3a76 331) to = strtoul(++endp, &endp, 10);
d17e3a76 333) if (endp != p + sep)
d17e3a76 334) from = -1;
d17e3a76 340) if (from < 0) {
d17e3a76 341) from = find_unique(p, items);
d17e3a76 342) if (from >= 0)
d17e3a76 343) to = from + 1;
d17e3a76 346) if (from < 0 || from >= items->items.nr ||
d17e3a76 347)     (singleton && from + 1 != to)) {
d17e3a76 350) break;
d17e3a76 351) } else if (singleton) {
d17e3a76 352) res = from;
d17e3a76 356) if (to > items->items.nr)
d17e3a76 357) to = items->items.nr;
d17e3a76 359) for (; from < to; from++)
d17e3a76 360) if (items->selected[from] != choose) {
d17e3a76 361) items->selected[from] = choose;
d17e3a76 362) res += choose ? +1 : -1;
d17e3a76 368) if ((immediate && res != LIST_AND_CHOOSE_ERROR) ||
d17e3a76 369)     !strcmp(input.buf, "*"))
d17e3a76 585) static void print_file_item(int i, int selected, struct string_list_item *item,
d17e3a76 618) printf("%c%2d: %s", selected ? '*' : ' ', i + 1, d->buf.buf);
d17e3a76 1025) static void print_command_item(int i, int selected,

Junio C Hamano	b0537b0e SQUASH??? tentative leakfix
sequencer.c
b0537b0e 5254) goto cleanup;

Martin Ågren	3bf986d6 builtin/config: collect "value_regexp" data in a struct
builtin/config.c
3bf986d6 329) FREE_AND_NULL(cmd_line_value.regexp);

Martin Ågren	3bcdd852 builtin/config: extract `handle_value_regex()` from `get_value()`
builtin/config.c
3bcdd852 330) return CONFIG_INVALID_PATTERN;
3bcdd852 375) goto free_strings;

Rohit Ashiwal	c068bcc5 sequencer: allow callers of read_author_script() to ignore fields
sequencer.c
c068bcc5 840) free(kv.items[date_i].util);

Rohit Ashiwal	cbd8db17 rebase -i: support --committer-date-is-author-date
sequencer.c
cbd8db17 890) return NULL;
cbd8db17 989) return -1;
cbd8db17 1428) goto out;
cbd8db17 1432) goto out;
cbd8db17 2587) opts->allow_ff = 0;
cbd8db17 2588) opts->committer_date_is_author_date = 1;

Rohit Ashiwal	08187b4c rebase -i: support --ignore-date
sequencer.c
08187b4c 903) return NULL;
08187b4c 920) argv_array_pushf(&child->env_array, "GIT_COMMITTER_DATE=%s", date.buf);
08187b4c 1492) res = -1;
08187b4c 1493) goto out;
08187b4c 2592) opts->allow_ff = 0;
08187b4c 2593) opts->ignore_date = 1;
08187b4c 3623) push_dates(&cmd, opts->committer_date_is_author_date);



Uncovered code in 'next' not in 'master'
--------------------------------------------------------

Commits introducting uncovered code:
Daniel Ferreira	5e82b9e4 built-in add -i: implement the `status` command
add-interactive.c
5e82b9e4 36) static void init_add_i_state(struct add_i_state *s, struct repository *r)
5e82b9e4 54) }
5e82b9e4 194) if (!list->nr)
5e82b9e4 195) return;
5e82b9e4 197) if (opts->header)
5e82b9e4 201) for (i = 0; i < list->nr; i++) {
5e82b9e4 202) opts->print_item(i, list->items + i, opts->print_item_data);
5e82b9e4 215) putchar('\n');
5e82b9e4 305) }
5e82b9e4 320) static void add_file_item(struct string_list *files, const char *name)
5e82b9e4 322) struct file_item *item = xcalloc(sizeof(*item), 1);
5e82b9e4 324) string_list_append(files, name)->util = item;
5e82b9e4 325) }
5e82b9e4 333) static int pathname_entry_cmp(const void *unused_cmp_data,
5e82b9e4 338) const struct pathname_entry *e1 =
5e82b9e4 340) const struct pathname_entry *e2 =
5e82b9e4 343) return strcmp(e1->name, name ? (const char *)name : e2->name);
5e82b9e4 355) static void collect_changes_cb(struct diff_queue_struct *q,
5e82b9e4 359) struct collection_status *s = data;
5e82b9e4 360) struct diffstat_t stat = { 0 };
5e82b9e4 363) if (!q->nr)
5e82b9e4 364) return;
5e82b9e4 366) compute_diffstat(options, &stat, q);
5e82b9e4 368) for (i = 0; i < stat.nr; i++) {
5e82b9e4 369) const char *name = stat.files[i]->name;
5e82b9e4 370) int hash = strhash(name);
5e82b9e4 375) entry = hashmap_get_entry_from_hash(&s->file_map, hash, name,
5e82b9e4 377) if (!entry) {
5e82b9e4 378) add_file_item(s->files, name);
5e82b9e4 380) entry = xcalloc(sizeof(*entry), 1);
5e82b9e4 381) hashmap_entry_init(&entry->ent, hash);
5e82b9e4 382) entry->name = s->files->items[s->files->nr - 1].string;
5e82b9e4 383) entry->item = s->files->items[s->files->nr - 1].util;
5e82b9e4 384) hashmap_add(&s->file_map, &entry->ent);
5e82b9e4 387) file_item = entry->item;
5e82b9e4 388) adddel = s->phase == FROM_INDEX ?
5e82b9e4 389) &file_item->index : &file_item->worktree;
5e82b9e4 390) adddel->seen = 1;
5e82b9e4 391) adddel->add = stat.files[i]->added;
5e82b9e4 392) adddel->del = stat.files[i]->deleted;
5e82b9e4 393) if (stat.files[i]->is_binary)
5e82b9e4 394) adddel->binary = 1;
5e82b9e4 396) free_diffstat_info(&stat);
5e82b9e4 399) static int get_modified_files(struct repository *r, struct string_list *files,
5e82b9e4 403) int is_initial = !resolve_ref_unsafe("HEAD", RESOLVE_REF_READING,
5e82b9e4 405) struct collection_status s = { FROM_WORKTREE };
5e82b9e4 407) if (discard_index(r->index) < 0 ||
5e82b9e4 408)     repo_read_index_preload(r, ps, 0) < 0)
5e82b9e4 411) string_list_clear(files, 1);
5e82b9e4 412) s.files = files;
5e82b9e4 413) hashmap_init(&s.file_map, pathname_entry_cmp, NULL, 0);
5e82b9e4 415) for (s.phase = FROM_WORKTREE; s.phase <= FROM_INDEX; s.phase++) {
5e82b9e4 417) struct setup_revision_opt opt = { 0 };
5e82b9e4 419) opt.def = is_initial ?
5e82b9e4 420) empty_tree_oid_hex() : oid_to_hex(&head_oid);
5e82b9e4 422) init_revisions(&rev, NULL);
5e82b9e4 423) setup_revisions(0, NULL, &rev, &opt);
5e82b9e4 425) rev.diffopt.output_format = DIFF_FORMAT_CALLBACK;
5e82b9e4 426) rev.diffopt.format_callback = collect_changes_cb;
5e82b9e4 427) rev.diffopt.format_callback_data = &s;
5e82b9e4 429) if (ps)
5e82b9e4 430) copy_pathspec(&rev.prune_data, ps);
5e82b9e4 432) if (s.phase == FROM_INDEX)
5e82b9e4 433) run_diff_index(&rev, 1);
5e82b9e4 435) rev.diffopt.flags.ignore_dirty_submodules = 1;
5e82b9e4 436) run_diff_files(&rev, 0);
5e82b9e4 439) hashmap_free_entries(&s.file_map, struct pathname_entry, ent);
5e82b9e4 442) string_list_sort(files);
5e82b9e4 444) return 0;
5e82b9e4 447) static void render_adddel(struct strbuf *buf,
5e82b9e4 450) if (ad->binary)
5e82b9e4 451) strbuf_addstr(buf, _("binary"));
5e82b9e4 452) else if (ad->seen)
5e82b9e4 453) strbuf_addf(buf, "+%"PRIuMAX"/-%"PRIuMAX,
5e82b9e4 454)     (uintmax_t)ad->add, (uintmax_t)ad->del);
5e82b9e4 456) strbuf_addstr(buf, no_changes);
5e82b9e4 457) }
5e82b9e4 481) static void print_file_item(int i, struct string_list_item *item,
5e82b9e4 484) struct file_item *c = item->util;
5e82b9e4 485) struct print_file_item_data *d = print_file_item_data;
5e82b9e4 487) strbuf_reset(&d->index);
5e82b9e4 488) strbuf_reset(&d->worktree);
5e82b9e4 489) strbuf_reset(&d->buf);
5e82b9e4 491) render_adddel(&d->worktree, &c->worktree, _("nothing"));
5e82b9e4 492) render_adddel(&d->index, &c->index, _("unchanged"));
5e82b9e4 493) strbuf_addf(&d->buf, d->modified_fmt,
5e82b9e4 496) printf(" %2d: %s", i + 1, d->buf.buf);
5e82b9e4 497) }
5e82b9e4 499) static int run_status(struct add_i_state *s, const struct pathspec *ps,
5e82b9e4 502) if (get_modified_files(s->r, files, ps) < 0)
5e82b9e4 503) return -1;
5e82b9e4 506) putchar('\n');
5e82b9e4 508) return 0;
5e82b9e4 573) struct add_i_state s = { NULL };
5e82b9e4 588) struct print_file_item_data print_file_item_data = {
5e82b9e4 591) struct list_options opts = {
5e82b9e4 594) struct strbuf header = STRBUF_INIT;
5e82b9e4 595) struct string_list files = STRING_LIST_INIT_DUP;
5e82b9e4 597) int res = 0;
5e82b9e4 606) init_add_i_state(&s, r);
5e82b9e4 617) strbuf_addstr(&header, "      ");
5e82b9e4 618) strbuf_addf(&header, print_file_item_data.modified_fmt,
5e82b9e4 620) opts.header = header.buf;
5e82b9e4 622) if (discard_index(r->index) < 0 ||
5e82b9e4 623)     repo_read_index(r) < 0 ||
5e82b9e4 624)     repo_refresh_and_write_index(r, REFRESH_QUIET, 0, 1,
5e82b9e4 628) res = run_status(&s, ps, &files, &opts);
5e82b9e4 644) string_list_clear(&files, 1);
5e82b9e4 645) strbuf_release(&print_file_item_data.buf);
5e82b9e4 646) strbuf_release(&print_file_item_data.index);
5e82b9e4 647) strbuf_release(&print_file_item_data.worktree);
5e82b9e4 648) strbuf_release(&header);
5e82b9e4 651) return res;

Derrick Stolee	4bd0593e test-tool: use 'read-graph' helper
t/helper/test-read-graph.c
4bd0593e 23) die_errno(_("Could not open commit-graph '%s'"), graph_name);
4bd0593e 27) return 1;

James Coglan	fbccf255 graph: automatically track display width of graph lines
graph.c
fbccf255 904) graph_line_write_column(line, col, '|');

James Coglan	0195285b graph: rename `new_mapping` to `old_mapping`
graph.c
0195285b 421) REALLOC_ARRAY(graph->old_mapping, graph->column_capacity * 2);

Jeff King	c5b4269b fsck: accept an oid instead of a "struct commit" for fsck_commit()
fsck.c
c5b4269b 781) return report(options, oid, OBJ_COMMIT, FSCK_MSG_MISSING_TREE, "invalid format - expected 'tree' line");
c5b4269b 783) err = report(options, oid, OBJ_COMMIT, FSCK_MSG_BAD_TREE_SHA1, "invalid 'tree' line format - bad sha1");
c5b4269b 790) err = report(options, oid, OBJ_COMMIT, FSCK_MSG_BAD_PARENT_SHA1, "invalid 'parent' line format - bad sha1");
c5b4269b 804) err = report(options, oid, OBJ_COMMIT, FSCK_MSG_MISSING_AUTHOR, "invalid format - expected 'author' line");
c5b4269b 810) return report(options, oid, OBJ_COMMIT, FSCK_MSG_MISSING_COMMITTER, "invalid format - expected 'committer' line");

Jeff King	103fb6d4 fsck: accept an oid instead of a "struct tag" for fsck_tag()
fsck.c
103fb6d4 837) ret = report(options, oid, OBJ_TAG, FSCK_MSG_MISSING_OBJECT, "invalid format - expected 'object' line");
103fb6d4 841) ret = report(options, oid, OBJ_TAG, FSCK_MSG_BAD_OBJECT_SHA1, "invalid 'object' line format - bad sha1");
103fb6d4 848) ret = report(options, oid, OBJ_TAG, FSCK_MSG_MISSING_TYPE_ENTRY, "invalid format - expected 'type' line");
103fb6d4 853) ret = report(options, oid, OBJ_TAG, FSCK_MSG_MISSING_TYPE, "invalid format - unexpected end after 'type' line");
103fb6d4 857) ret = report(options, oid, OBJ_TAG, FSCK_MSG_BAD_TYPE, "invalid 'type' value");
103fb6d4 863) ret = report(options, oid, OBJ_TAG, FSCK_MSG_MISSING_TAG_ENTRY, "invalid format - expected 'tag' line");
103fb6d4 868) ret = report(options, oid, OBJ_TAG, FSCK_MSG_MISSING_TAG, "invalid format - unexpected end after 'type' line");

Jeff King	6da40b22 fsck: accept an oid instead of a "struct blob" for fsck_blob()
fsck.c
6da40b22 958) return report(options, oid, OBJ_BLOB,

Jeff King	38370253 fsck: don't require an object struct for report()
fsck.c
38370253 980) return report(options, NULL, OBJ_NONE, FSCK_MSG_BAD_OBJECT_SHA1, "no valid object to fsck");
38370253 991) return report(options, &obj->oid, obj->type,
38370253 994)       obj->type);
38370253 1029) ret |= report(options,

Jeff King	b8b00f16 fsck: drop blob struct from fsck_finish()
fsck.c
b8b00f16 1027) if (is_promisor_object(oid))

Jeff King	cc579000 fsck: don't require an object struct in verify_headers()
fsck.c
cc579000 717) return report(options, oid, type,

Jeff King	7b143c16 pack-bitmap: introduce bitmap_walk_contains()
pack-bitmap.c
7b143c16 903) return 0;

Jeff King	f66e0401 pack-objects: avoid pointless oe_map_new_pack() calls
pack-objects.c
f66e0401 122) if (pack->in_pack)
f66e0401 125) ALLOC_ARRAY(pack->in_pack, pack->nr_alloc);

Jeff King	ad7a4032 send-pack: check remote ref status on pack-objects failure
send-pack.c
ad7a4032 580) receive_status(&reader, remote_refs);

Jeff King	228c78fb commit, tag: don't set parsed bit for parse failures
tag.c
228c78fb 152) FREE_AND_NULL(item->tag);

Jeff King	78543993 fsck: don't require an object struct for fsck_ident()
fsck.c
78543993 733) return report(options, oid, type, FSCK_MSG_MISSING_NAME_BEFORE_EMAIL, "invalid author/committer line - missing space before email");
78543993 740) return report(options, oid, type, FSCK_MSG_MISSING_SPACE_BEFORE_EMAIL, "invalid author/committer line - missing space before email");
78543993 744) return report(options, oid, type, FSCK_MSG_BAD_EMAIL, "invalid author/committer line - bad email");
78543993 750) return report(options, oid, type, FSCK_MSG_ZERO_PADDED_DATE, "invalid author/committer line - zero-padded date");
78543993 754) return report(options, oid, type, FSCK_MSG_BAD_DATE, "invalid author/committer line - bad date");
78543993 762) return report(options, oid, type, FSCK_MSG_BAD_TIMEZONE, "invalid author/committer line - bad time zone");

Jeff King	b2f2039c fsck: accept an oid instead of a "struct tree" for fsck_tree()
fsck.c
b2f2039c 622) retval += report(options, oid, OBJ_TREE, FSCK_MSG_BAD_TREE, "cannot be parsed as a tree");
b2f2039c 669) retval += report(options, oid, OBJ_TREE, FSCK_MSG_FULL_PATHNAME, "contains full pathnames");
b2f2039c 671) retval += report(options, oid, OBJ_TREE, FSCK_MSG_EMPTY_NAME, "contains empty pathname");
b2f2039c 679) retval += report(options, oid, OBJ_TREE, FSCK_MSG_ZERO_PADDED_FILEMODE, "contains zero-padded file modes");
b2f2039c 681) retval += report(options, oid, OBJ_TREE, FSCK_MSG_BAD_FILEMODE, "contains bad file modes");
b2f2039c 685) retval += report(options, oid, OBJ_TREE, FSCK_MSG_TREE_NOT_SORTED, "not properly sorted");

Jeff King	73390290 fsck: use oids rather than objects for object_name API
fsck.c
73390290 400) fsck_put_object_name(options, &entry.oid, "%s%s/",
73390290 469) fsck_put_object_name(options, oid, "%s^%d",
73390290 472) fsck_put_object_name(options, oid, "%.*s~%d",
73390290 495) fsck_put_object_name(options, &tag->tagged->oid, "%s", name);

Jeff King	7cb9754e pack-objects: introduce pack.allowPackReuse
builtin/pack-objects.c
7cb9754e 2834) allow_pack_reuse = git_config_bool(k, v);
7cb9754e 2835) return 0;

Jeff King	4f0bd8b9 pack-objects: improve partial packfile reuse
builtin/pack-objects.c
4f0bd8b9 1124) return 1;
4f0bd8b9 2681) (reuse_packfile_bitmap &&
4f0bd8b9 2682)  bitmap_walk_contains(bitmap_git, reuse_packfile_bitmap, oid));

pack-bitmap.c
4f0bd8b9 808) return;
4f0bd8b9 811) return;
4f0bd8b9 823) return;
4f0bd8b9 861) i = bitmap_git->pack->num_objects / BITS_IN_EWORD;

Jeff King	82ef89b3 fsck: don't require object structs for display functions
builtin/fsck.c
82ef89b3 64) type = oid_object_info(the_repository, oid, NULL);
82ef89b3 309) printf_ln(_("unreachable %s %s"),
82ef89b3 310)   printable_type(&obj->oid, obj->type),
82ef89b3 311)   describe_object(&obj->oid));
82ef89b3 367) fprintf_ln(stderr, _("Checking %s"), describe_object(&obj->oid));
82ef89b3 425)    printable_type(&obj->oid, obj->type),
82ef89b3 426)    describe_object(&obj->oid));
82ef89b3 439)   describe_object(&commit->object.oid));

Johannes Schindelin	116d1fa6 vreportf(): avoid relying on stdio buffering
usage.c
116d1fa6 16) fprintf(stderr, "BUG!!! too long a prefix '%s'\n", prefix);
116d1fa6 17) abort();
116d1fa6 22) *p = '\0'; /* vsnprintf() failed, clip at prefix */

Johannes Schindelin	68db1cbf built-in add -i: support `?` (prompt help)
add-interactive.c
68db1cbf 50) init_color(r, s, "help", s->help_color, GIT_COLOR_BOLD_RED);
68db1cbf 263) if (!strcmp(input.buf, "?")) {
68db1cbf 264) opts->print_help(s);
68db1cbf 265) continue;
68db1cbf 559) static void command_prompt_help(struct add_i_state *s)
68db1cbf 561) const char *help_color = s->help_color;
68db1cbf 562) color_fprintf_ln(stdout, help_color, "%s", _("Prompt help:"));
68db1cbf 563) color_fprintf_ln(stdout, help_color, "1          - %s",
68db1cbf 565) color_fprintf_ln(stdout, help_color, "foo        - %s",
68db1cbf 567) color_fprintf_ln(stdout, help_color, "           - %s",
68db1cbf 569) }

Johannes Schindelin	76b74323 built-in add -i: show unique prefixes of the commands
add-interactive.c
76b74323 80) static void prefix_item_list_clear(struct prefix_item_list *list)
76b74323 82) string_list_clear(&list->items, 1);
76b74323 83) string_list_clear(&list->sorted, 0);
76b74323 84) }
76b74323 86) static void extend_prefix_length(struct string_list_item *p,
76b74323 89) size_t *len = p->util;
76b74323 91) if (!*len || memcmp(p->string, other_string, *len))
76b74323 92) return;
76b74323 95) char c = p->string[*len];
76b74323 103) if (!c || ++*len > max_length || !isascii(c)) {
76b74323 104) *len = 0;
76b74323 105) break;
76b74323 108) if (c != other_string[*len - 1])
76b74323 109) break;
76b74323 110) }
76b74323 113) static void find_unique_prefixes(struct prefix_item_list *list)
76b74323 117) if (list->sorted.nr == list->items.nr)
76b74323 118) return;
76b74323 120) string_list_clear(&list->sorted, 0);
76b74323 122) list->sorted.items = xmalloc(st_mult(sizeof(*list->sorted.items),
76b74323 123)      list->items.nr));
76b74323 124) list->sorted.nr = list->sorted.alloc = list->items.nr;
76b74323 126) for (i = 0; i < list->items.nr; i++) {
76b74323 127) list->sorted.items[i].string = list->items.items[i].string;
76b74323 128) list->sorted.items[i].util = list->items.items + i;
76b74323 131) string_list_sort(&list->sorted);
76b74323 133) for (i = 0; i < list->sorted.nr; i++) {
76b74323 134) struct string_list_item *sorted_item = list->sorted.items + i;
76b74323 135) struct string_list_item *item = sorted_item->util;
76b74323 136) size_t *len = item->util;
76b74323 138) *len = 0;
76b74323 139) while (*len < list->min_length) {
76b74323 140) char c = item->string[(*len)++];
76b74323 142) if (!c || !isascii(c)) {
76b74323 143) *len = 0;
76b74323 144) break;
76b74323 148) if (i > 0)
76b74323 149) extend_prefix_length(item, sorted_item[-1].string,
76b74323 151) if (i + 1 < list->sorted.nr)
76b74323 152) extend_prefix_length(item, sorted_item[1].string,
76b74323 157) static ssize_t find_unique(const char *string, struct prefix_item_list *list)
76b74323 159) int index = string_list_find_insert_index(&list->sorted, string, 1);
76b74323 162) if (list->items.nr != list->sorted.nr)
76b74323 167) if (index < 0)
76b74323 168) item = list->sorted.items[-1 - index].util;
76b74323 169) else if (index > 0 &&
76b74323 170)  starts_with(list->sorted.items[index - 1].string, string))
76b74323 171) return -1;
76b74323 172) else if (index + 1 < list->sorted.nr &&
76b74323 173)  starts_with(list->sorted.items[index + 1].string, string))
76b74323 174) return -1;
76b74323 175) else if (index < list->sorted.nr)
76b74323 176) item = list->sorted.items[index].util;
76b74323 178) return -1;
76b74323 179) return item - list->items.items;
76b74323 233) static ssize_t list_and_choose(struct add_i_state *s,
76b74323 240) find_unique_prefixes(items);
76b74323 247) list(s, &items->items, &opts->list_opts);
76b74323 289) if (index < 0)
76b74323 290) index = find_unique(p, items);
76b74323 292) if (index < 0 || index >= items->items.nr)
76b74323 460) static int is_valid_prefix(const char *prefix, size_t prefix_len)
76b74323 462) return prefix_len && prefix &&
76b74323 468) strcspn(prefix, " \t\r\n,") >= prefix_len &&	/* separators */
76b74323 469) *prefix != '-' &&				/* deselection */
76b74323 470) !isdigit(*prefix) &&				/* selection */
76b74323 471) (prefix_len != 1 ||
76b74323 472)  (*prefix != '*' &&				/* "all" wildcard */
76b74323 473)   *prefix != '?'));				/* prompt help */
76b74323 548) struct command_item *util = item->util;
76b74323 550) if (!util->prefix_length ||
76b74323 551)     !is_valid_prefix(item->string, util->prefix_length))
76b74323 552) printf(" %2d: %s", i + 1, item->string);
76b74323 586) struct prefix_item_list commands = PREFIX_ITEM_LIST_INIT;
76b74323 599) for (i = 0; i < ARRAY_SIZE(command_list); i++) {
76b74323 600) struct command_item *util = xcalloc(sizeof(*util), 1);
76b74323 601) util->command = command_list[i].command;
76b74323 602) string_list_append(&commands.items, command_list[i].string)
76b74323 603) ->util = util;
76b74323 638) struct command_item *util =
76b74323 639) commands.items.items[i].util;
76b74323 640) res = util->command(&s, ps, &files, &opts);
76b74323 649) prefix_item_list_clear(&commands);

Johannes Schindelin	867bc1d2 rebase-merges: move labels' whitespace mangling into `label_oid()`
sequencer.c
867bc1d2 4523) }

Johannes Schindelin	6348bfba built-in add -i: implement the main loop
add-interactive.c
6348bfba 192) int i, last_lf = 0;
6348bfba 204) if ((opts->columns) && ((i + 1) % (opts->columns))) {
6348bfba 205) putchar('\t');
6348bfba 206) last_lf = 0;
6348bfba 209) putchar('\n');
6348bfba 210) last_lf = 1;
6348bfba 214) if (!last_lf)
6348bfba 237) struct strbuf input = STRBUF_INIT;
6348bfba 238) ssize_t res = LIST_AND_CHOOSE_ERROR;
6348bfba 245) strbuf_reset(&input);
6348bfba 251) fflush(stdout);
6348bfba 253) if (strbuf_getline(&input, stdin) == EOF) {
6348bfba 254) putchar('\n');
6348bfba 255) res = LIST_AND_CHOOSE_QUIT;
6348bfba 256) break;
6348bfba 258) strbuf_trim(&input);
6348bfba 260) if (!input.len)
6348bfba 261) break;
6348bfba 268) p = input.buf;
6348bfba 270) size_t sep = strcspn(p, " \t\r\n,");
6348bfba 271) ssize_t index = -1;
6348bfba 273) if (!sep) {
6348bfba 274) if (!*p)
6348bfba 275) break;
6348bfba 276) p++;
6348bfba 277) continue;
6348bfba 280) if (isdigit(*p)) {
6348bfba 282) index = strtoul(p, &endp, 10) - 1;
6348bfba 283) if (endp != p + sep)
6348bfba 284) index = -1;
6348bfba 287) if (p[sep])
6348bfba 288) p[sep++] = '\0';
6348bfba 296) res = index;
6348bfba 297) break;
6348bfba 300) p += sep;
6348bfba 301) }
6348bfba 303) if (res != LIST_AND_CHOOSE_ERROR)
6348bfba 304) break;
6348bfba 307) strbuf_release(&input);
6348bfba 308) return res;
6348bfba 544) static void print_command_item(int i, struct string_list_item *item,
6348bfba 557) }
6348bfba 575) struct list_and_choose_options main_loop_opts = {
6348bfba 582) } command_list[] = {
6348bfba 631) i = list_and_choose(&s, &commands, &main_loop_opts);
6348bfba 632) if (i == LIST_AND_CHOOSE_QUIT) {
6348bfba 633) printf(_("Bye.\n"));
6348bfba 634) res = 0;
6348bfba 635) break;
6348bfba 637) if (i != LIST_AND_CHOOSE_ERROR) {
6348bfba 642) }

Johannes Schindelin	4d17fd25 remote-curl: unbreak http.extraHeader with custom allocators
http.c
4d17fd25 417) string_list_clear(&extra_http_headers, 0);

Johannes Schindelin	f83dff60 Start to implement a built-in version of `git add --interactive`
add-interactive.c
f83dff60 571) int run_add_i(struct repository *r, const struct pathspec *ps)

builtin/add.c
f83dff60 197) return !!run_add_i(the_repository, pathspec);

Johannes Schindelin	2e0afafe Add git-bundle: move objects and references by archive
builtin/bundle.c
2e0afafe 115) return 1;

Matthew Rogers	cd552227 rebase -r: let `label` generate safer labels
sequencer.c
cd552227 4498) strbuf_addstr(buf, "rev-");
cd552227 4499) strbuf_add_unique_abbrev(buf, oid, default_abbrev);

Robin H. Johnson	73c3253d bundle: framework for options before bundle file
builtin/bundle.c
73c3253d 138) return 1;
73c3253d 143) static int cmd_bundle_unbundle(int argc, const char **argv, const char *prefix) {
73c3253d 145) int bundle_fd = -1;
73c3253d 147) struct option options[] = {
73c3253d 152) argc = parse_options_cmd_bundle(argc, argv, prefix,
73c3253d 156) memset(&header, 0, sizeof(header));
73c3253d 157) if ((bundle_fd = read_bundle_header(bundle_file, &header)) < 0)
73c3253d 158) return 1;
73c3253d 159) if (!startup_info->have_repository)
73c3253d 161) return !!unbundle(the_repository, &header, bundle_fd, 0) ||
73c3253d 162) list_bundle_refs(&header, argc, argv);
73c3253d 187) else if (!strcmp(argv[0], "unbundle"))
73c3253d 188) result = cmd_bundle_unbundle(argc, argv, prefix);

Robin H. Johnson	79862b6b bundle-create: progress output control
builtin/bundle.c
79862b6b 85) else if (progress == 1)
79862b6b 86) argv_array_push(&pack_opts, "--progress");
79862b6b 87) else if (progress == 2)
79862b6b 88) argv_array_push(&pack_opts, "--all-progress");
79862b6b 90) argv_array_push(&pack_opts, "--all-progress-implied");

Slavica Đukić	3d965c76 built-in add -i: use color in the main loop
add-interactive.c
3d965c76 51) init_color(r, s, "prompt", s->prompt_color, GIT_COLOR_BOLD_BLUE);
3d965c76 52) init_color(r, s, "error", s->error_color, GIT_COLOR_BOLD_RED);
3d965c76 53) init_color(r, s, "reset", s->reset_color, GIT_COLOR_RESET);
3d965c76 249) color_fprintf(stdout, s->prompt_color, "%s", opts->prompt);
3d965c76 250) fputs("> ", stdout);
3d965c76 293) color_fprintf_ln(stdout, s->error_color,
3d965c76 547) struct print_command_item_data *d = print_command_item_data;
3d965c76 554) printf(" %2d: %s%.*s%s%s", i + 1,
3d965c76 555)        d->color, (int)util->prefix_length, item->string,
3d965c76 556)        d->reset, item->string + util->prefix_length);
3d965c76 574) struct print_command_item_data data = { "[", "]" };
3d965c76 612) if (s.use_color) {
3d965c76 613) data.color = s.prompt_color;
3d965c76 614) data.reset = s.reset_color;

Slavica Đukić	8c159044 built-in add -i: implement the `help` command
add-interactive.c
8c159044 511) static int run_help(struct add_i_state *s, const struct pathspec *unused_ps,
8c159044 515) color_fprintf_ln(stdout, s->help_color, "status        - %s",
8c159044 517) color_fprintf_ln(stdout, s->help_color, "update        - %s",
8c159044 519) color_fprintf_ln(stdout, s->help_color, "revert        - %s",
8c159044 521) color_fprintf_ln(stdout, s->help_color, "patch         - %s",
8c159044 523) color_fprintf_ln(stdout, s->help_color, "diff          - %s",
8c159044 525) color_fprintf_ln(stdout, s->help_color, "add untracked - %s",
8c159044 528) return 0;

Slavica Đukić	1daaebca built-in add -i: color the header in the `status` command
add-interactive.c
1daaebca 20) static void init_color(struct repository *r, struct add_i_state *s,
1daaebca 24) char *key = xstrfmt("color.interactive.%s", slot_name);
1daaebca 27) if (!s->use_color)
1daaebca 28) dst[0] = '\0';
1daaebca 29) else if (repo_config_get_value(r, key, &value) ||
1daaebca 30)  color_parse(value, dst))
1daaebca 31) strlcpy(dst, default_color, COLOR_MAXLEN);
1daaebca 33) free(key);
1daaebca 34) }
1daaebca 40) s->r = r;
1daaebca 42) if (repo_config_get_value(r, "color.interactive", &value))
1daaebca 43) s->use_color = -1;
1daaebca 45) s->use_color =
1daaebca 46) git_config_colorbool("color.interactive", value);
1daaebca 47) s->use_color = want_color(s->use_color);
1daaebca 49) init_color(r, s, "header", s->header_color, GIT_COLOR_BOLD);
1daaebca 189) static void list(struct add_i_state *s, struct string_list *list,
1daaebca 198) color_fprintf_ln(stdout, s->header_color,
1daaebca 505) list(s, files, opts);



Uncovered code in 'master' not in 'master@{1}'
--------------------------------------------------------

Commits introducting uncovered code:
Phillip Wood	49697cb7 move run_commit_hook() to libgit and use it there
sequencer.c
49697cb7 1137) arg1 = "commit";
49697cb7 1138) arg2 = commit;

SZEDER Gábor	c72fc40d path.c: clarify two field names in 'struct common_dir'
path.c
c72fc40d 380) for (p = common_list; p->path; p++) {
c72fc40d 381) const char *path = p->path;

William Baker	840cef0c midx: add progress to write_midx_file
midx.c
840cef0c 973) progress = start_progress(_("Writing chunks to multi-pack-index"),



