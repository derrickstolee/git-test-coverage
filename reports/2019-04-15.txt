pu	439c82729488c750d078f44a43d77be95d7453ce
jch	59c8c136fa57d41045da9b8231ad2df08b5f0ae5
next	511ec345e18b91bfc070cff61e34b433cb3e5a41
master	e35b8cb8e212e3557efc565157ceb5cbaaf0d87f
master@{1}	origin/maint


Uncovered code in 'pu' not in 'jch'
--------------------------------------------------------

blame.c
35e314c6 519)     ent->ignored == next->ignored &&
718e473b 520)     ent->unblamable == next->unblamable) {
718e473b 1201) ignoredp_tail = ignoredp_tail->next;
718e473b 1791) continue;

builtin/blame.c
718e473b 492) memset(hex, '0', length);
718e473b 715) return ret;

builtin/cat-file.c
3f82acbc 528) warning("This repository uses promisor remotes. Some objects may not be loaded.");

builtin/commit.c
8e7e6c05 1673) return 1;

builtin/config.c
a12c1ff3 110) die(_("$HOME not set"));
a12c1ff3 122) given_config_source.file = git_etc_gitconfig();
6f11fd5e 489) BUG("action %d cannot get here", actions);
6f11fd5e 503) die(_("unknown config source"));
6f11fd5e 509) die(_("invalid key pattern: %s"), key);

builtin/fetch-pack.c
bf01639c 249) warning(_("Lockfile created but not reported: %s"),
bf01639c 250) pack_lockfiles.items[i].string);

builtin/gc.c
8e7e6c05 692) return 1;

builtin/pack-objects.c
820a5361 858) BUG("configured exclusion wasn't configured");
820a5361 2793) die(_("value of uploadpack.blobpackfileuri must be "
820a5361 2796) die(_("object already configured in another "

builtin/rebase.c
9f6017ea 147) static int add_exec_commands(struct string_list *commands)
9f6017ea 149) const char *todo_file = rebase_path_todo();
9f6017ea 150) struct todo_list todo_list = TODO_LIST_INIT;
9f6017ea 153) if (strbuf_read_file(&todo_list.buf, todo_file, 0) < 0)
9f6017ea 154) return error_errno(_("could not read '%s'."), todo_file);
9f6017ea 156) if (todo_list_parse_insn_buffer(the_repository, todo_list.buf.buf,
9f6017ea 158) todo_list_release(&todo_list);
9f6017ea 159) return error(_("unusable todo list: '%s'"), todo_file);
9f6017ea 162) todo_list_add_exec_commands(&todo_list, commands);
9f6017ea 163) res = todo_list_write_to_file(the_repository, &todo_list,
9f6017ea 165) todo_list_release(&todo_list);
9f6017ea 167) if (res)
9f6017ea 168) return error_errno(_("could not write '%s'."), todo_file);
9f6017ea 169) return 0;
9f6017ea 172) static int rearrange_squash_in_todo_file(void)
9f6017ea 174) const char *todo_file = rebase_path_todo();
9f6017ea 175) struct todo_list todo_list = TODO_LIST_INIT;
9f6017ea 176) int res = 0;
9f6017ea 178) if (strbuf_read_file(&todo_list.buf, todo_file, 0) < 0)
9f6017ea 179) return error_errno(_("could not read '%s'."), todo_file);
9f6017ea 180) if (todo_list_parse_insn_buffer(the_repository, todo_list.buf.buf,
9f6017ea 182) todo_list_release(&todo_list);
9f6017ea 183) return error(_("unusable todo list: '%s'"), todo_file);
9f6017ea 186) res = todo_list_rearrange_squash(&todo_list);
9f6017ea 187) if (!res)
9f6017ea 188) res = todo_list_write_to_file(the_repository, &todo_list,
9f6017ea 191) todo_list_release(&todo_list);
9f6017ea 193) if (res)
9f6017ea 194) return error_errno(_("could not write '%s'."), todo_file);
9f6017ea 195) return 0;
9f6017ea 205) return error_errno(_("could not read '%s'."), todo_file);
9f6017ea 209) todo_list_release(&todo_list);
9f6017ea 210) return error(_("unusable todo list: '%s'"), todo_file);
9f6017ea 218) return error_errno(_("could not write '%s'."), todo_file);
9f6017ea 230) return error_errno(_("could not read '%s'."), todo_file);
9f6017ea 236) res = error_errno(_("could not write '%s'"), todo_file);
9f6017ea 253) return error(_("no HEAD?"));
645897ae 280) return error_errno(_("could not create temporary %s"), merge_dir());
9f6017ea 286) return error_errno(_("could not mark as interactive"));
9f6017ea 315) return -1;
9f6017ea 319) return -1;
9f6017ea 324) free(revisions);
9f6017ea 325) free(shortrevisions);
9f6017ea 327) return -1;
21604b24 336) argv_array_push(&make_script_args,
e08571cf 337) oid_to_hex(&opts->restrict_revision->object.oid));
9f6017ea 344) error(_("could not generate todo list"));
9f6017ea 349) BUG("unusable todo list");
4b7dc0bd 383) die(_("a base commit must be provided with --upstream or --onto"));
4b7dc0bd 420) ret = rearrange_squash_in_todo_file();
4b7dc0bd 421) break;
4b7dc0bd 423) struct string_list commands = STRING_LIST_INIT_DUP;
4b7dc0bd 425) split_exec_commands(opts->cmd, &commands);
4b7dc0bd 426) ret = add_exec_commands(&commands);
4b7dc0bd 427) string_list_clear(&commands, 0);
4b7dc0bd 428) break;
4b7dc0bd 431) BUG("invalid command '%d'", command);
9f6017ea 510) usage_with_options(builtin_rebase_interactive_usage, options);
4d5498a8 516) opts.squash_onto = &squash_onto;
9f6017ea 519) warning(_("--[no-]rebase-cousins has no effect without "

builtin/tag.c
01dc801a 226) die(_("bad object type."));

commit-graph.c
b1beb050 931) error(_("unsupported commit-graph version %d"),
b1beb050 933) return 1;
8e7e6c05 983) error(_("error adding pack %s"), packname.buf);
8e7e6c05 984) res = 1;
8e7e6c05 985) goto cleanup;
8e7e6c05 988) error(_("error opening index for %s"), packname.buf);
8e7e6c05 989) res = 1;
8e7e6c05 990) goto cleanup;
8e7e6c05 1063) error(_("the commit graph format cannot write %d commits"), count_distinct);
8e7e6c05 1064) res = 1;
8e7e6c05 1065) goto cleanup;
8e7e6c05 1099) error(_("too many commits to write graph"));
8e7e6c05 1100) res = 1;
8e7e6c05 1101) goto cleanup;
8e7e6c05 1109) error(_("unable to create leading directories of %s"),
8e7e6c05 1111) res = errno;
8e7e6c05 1112) goto cleanup;

config.c
8f7c7f55 2143) int repo_config_set_gently(struct repository *r,
8f7c7f55 2146) char *path = repo_git_path(r, "config");
8f7c7f55 2147) int ret = git_config_set_multivar_in_file_gently(path, key, value, NULL, 0);
8f7c7f55 2148) free(path);
8f7c7f55 2149) return ret;
8f7c7f55 2152) void repo_config_set(struct repository *r, const char *key, const char *value)
8f7c7f55 2154) if (!repo_config_set_gently(r, key, value))
8f7c7f55 2155) return;
8f7c7f55 2156) if (value)
8f7c7f55 2157) die(_("could not set '%s' to '%s'"), key, value);
8f7c7f55 2159) die(_("could not unset '%s'"), key);
8f7c7f55 2162) int repo_config_set_worktree_gently(struct repository *r,
8f7c7f55 2168) path = get_worktree_config(r);
8f7c7f55 2169) if (!path)
8f7c7f55 2170) return CONFIG_INVALID_FILE;
8f7c7f55 2171) ret = git_config_set_multivar_in_file_gently(path, key, value, NULL, 0);
8f7c7f55 2172) free(path);
8f7c7f55 2173) return ret;

fetch-pack.c
820a5361 1388) die("expected '<hash> <uri>', got: %s\n", reader->line);
820a5361 1393) die("expected DELIM");
820a5361 1520) die("fetch-pack: unable to spawn http-fetch");
820a5361 1524) die("fetch-pack: expected keep then TAB at start of http-fetch output");
820a5361 1529) die("fetch-pack: expected hash then LF at end of http-fetch output");
820a5361 1536) die("fetch-pack: unable to finish http-fetch");
820a5361 1540) die("fetch-pack: pack downloaded from %s does not match expected hash %.*s",
820a5361 1541)     uri, (int) the_hash_algo->hexsz,
820a5361 1542)     packfile_uris.items[i].string);

http-fetch.c
472fbef8 75) die("couldn't create http pack request");
472fbef8 82) die("Unable to get pack file %s\n%s", preq->url,
472fbef8 86) die("Unable to start request");
472fbef8 101) walker_targets_free(commits, commit_id, write_ref);
472fbef8 104) fprintf(stderr,

http.c
ba81921a 2005) if (fflush((FILE *)result)) {
ba81921a 2009) rewind((FILE *)result);
ba81921a 2010) if (ftruncate(fileno((FILE *)result), 0) < 0) {
1a11b378 2302) target ? hash_to_hex(target->hash) : base_url,

merge-recursive.c
259ccb6c 317) strbuf_addstr(&opt->obuf, _("(bad commit)\n"));
259ccb6c 340) return err(opt, _("add_cacheinfo failed for path '%s'; merge aborting."), path);
259ccb6c 349) return err(opt, _("add_cacheinfo failed to refresh for path '%s'; merge aborting."), path);
259ccb6c 432) err(opt, _("error building trees"));
259ccb6c 687) ce = index_file_exists(opt->repo->index, path, strlen(path),
259ccb6c 881) return err(opt, msg, path, _(": perhaps a D/F conflict?"));
259ccb6c 882) return err(opt, msg, path, "");
8daec1df 931) return err(opt, _("cannot read object %s '%s'"),
8daec1df 934) ret = err(opt, _("blob expected for %s '%s'"),
259ccb6c 958) ret = err(opt, _("failed to open '%s': %s"),
259ccb6c 969) ret = err(opt, _("failed to symlink '%s': %s"),
259ccb6c 973) ret = err(opt,
8daec1df 975)   contents->mode, oid_to_hex(&contents->oid), path);
259ccb6c 1177) output(opt, 1, _("Failed to merge submodule %s (commits not present)"), path);
259ccb6c 1194) } else if (show(opt, 2))
259ccb6c 1195) output(opt, 2, _("Fast-forwarding submodule %s"), path);
259ccb6c 1203) if (show(opt, 3)) {
259ccb6c 1204) output(opt, 3, _("Fast-forwarding submodule %s to the following commit:"), path);
259ccb6c 1205) output_commit_title(opt, commit_a);
259ccb6c 1206) } else if (show(opt, 2))
259ccb6c 1207) output(opt, 2, _("Fast-forwarding submodule %s"), path);
e3de888c 1272) return merge_mode_and_contents(opt, o, b, a,
259ccb6c 1320) ret = err(opt, _("Failed to execute internal merge"));
259ccb6c 1325) ret = err(opt, _("Unable to add %s to database"),
8c8e5bd6 1398) return -1;
8c8e5bd6 1403) return -1;
8daec1df 1741) if (update_file(opt, 0, add, a->path))
8daec1df 1748) if (update_file(opt, 0, add, b->path))
259ccb6c 2924) return err(opt, _("cannot read object %s"), oid_to_hex(oid));
259ccb6c 2927) return err(opt, _("object %s is not a blob"), oid_to_hex(oid));
259ccb6c 3063) remove_file_from_index(opt->repo->index, path);
8c8e5bd6 3117) return -1;
8c8e5bd6 3179) BUG("Impossible dir_rename_original_type/clean combination");
8daec1df 3357) } else if (!o_valid && !a_valid && !b_valid) {
8daec1df 3362) remove_file(opt, 1, path, !a->mode);
259ccb6c 3457) unpack_trees_finish(opt);
259ccb6c 3551) return err(opt, _("merge returned no commit"));
259ccb6c 3617) return err(opt, _("Could not parse object '%s'"),
259ccb6c 3633) return err(opt, _("Unable to write index."));
8c8e5bd6 3656) } else if (!strcasecmp(value, "conflict")) {
8c8e5bd6 3657) opt->detect_directory_renames = 1;
259ccb6c 3699) opt->subtree_shift = "";
259ccb6c 3703) opt->xdl_opts = DIFF_WITH_ALG(opt, PATIENCE_DIFF);
259ccb6c 3705) opt->xdl_opts = DIFF_WITH_ALG(opt, HISTOGRAM_DIFF);
259ccb6c 3711) DIFF_XDL_CLR(opt, NEED_MINIMAL);
259ccb6c 3712) opt->xdl_opts &= ~XDF_DIFF_ALGORITHM_MASK;
259ccb6c 3713) opt->xdl_opts |= value;
259ccb6c 3722) DIFF_XDL_SET(opt, IGNORE_CR_AT_EOL);
259ccb6c 3724) opt->renormalize = 1;
259ccb6c 3726) opt->renormalize = 0;

oidset.c
3486d8d4 69) die_errno("Could not read '%s'", path);

parse-options-cb.c
21604b24 99) int parse_opt_commit(const struct option *opt, const char *arg, int unset)
21604b24 103) struct commit **target = opt->value;
21604b24 105) if (!arg)
21604b24 106) return -1;
21604b24 107) if (get_oid(arg, &oid))
21604b24 108) return error("malformed object name %s", arg);
21604b24 109) commit = lookup_commit_reference(the_repository, &oid);
21604b24 110) if (!commit)
21604b24 111) return error("no such commit %s", arg);
21604b24 112) *target = commit;
21604b24 113) return 0;
33d250cd 132) int parse_opt_object_id(const struct option *opt, const char *arg, int unset)
33d250cd 135) struct object_id *target = opt->value;
33d250cd 137) if (unset) {
33d250cd 138) *target = null_oid;
33d250cd 139) return 0;
33d250cd 141) if (!arg)
33d250cd 142) return -1;
33d250cd 143) if (get_oid(arg, &oid))
33d250cd 144) return error(_("malformed object name '%s'"), arg);
33d250cd 145) *target = oid;
33d250cd 146) return 0;

promisor-remote.c
f51395f1 15) warning(_("promisor remote name cannot begin with '/': %s"),
f51395f1 17) return NULL;
8b75bfd2 47) previous->next = r->next;
76fa09af 89) return 0;
e52d417b 152) static int remove_fetched_oids(struct object_id **oids, int oid_nr, int to_free)
e52d417b 154) int i, missing_nr = 0;
e52d417b 155) int *missing = xcalloc(oid_nr, sizeof(*missing));
e52d417b 156) struct object_id *old_oids = *oids;
e52d417b 158) int old_fetch_if_missing = fetch_if_missing;
e52d417b 160) fetch_if_missing = 0;
e52d417b 162) for (i = 0; i < oid_nr; i++)
e52d417b 163) if (oid_object_info_extended(the_repository, &old_oids[i], NULL, 0)) {
e52d417b 164) missing[i] = 1;
e52d417b 165) missing_nr++;
e52d417b 168) fetch_if_missing = old_fetch_if_missing;
e52d417b 170) if (missing_nr) {
e52d417b 171) int j = 0;
e52d417b 172) new_oids = xcalloc(missing_nr, sizeof(*new_oids));
e52d417b 173) for (i = 0; i < oid_nr; i++)
e52d417b 174) if (missing[i])
e52d417b 175) oidcpy(&new_oids[j++], &old_oids[i]);
e52d417b 176) *oids = new_oids;
e52d417b 177) if (to_free)
e52d417b 178) free(old_oids);
e52d417b 181) return missing_nr;
e52d417b 196) if (missing_nr == 1)
e52d417b 197) continue;
e52d417b 198) missing_nr = remove_fetched_oids(&missing_oids, missing_nr, to_free);
e52d417b 199) if (missing_nr) {
e52d417b 200) to_free = 1;
e52d417b 201) continue;
e52d417b 209) free(missing_oids);

protocol.c
6da1f1a9 37) die(_("Unrecognized protocol version"));
6da1f1a9 39) die(_("Unrecognized protocol_version"));
6da1f1a9 74) BUG("late attempt to register an allowed protocol version");

ref-filter.c
3da20422 93) keydata_aka_refname ? keydata_aka_refname : k->wt->head_ref);

remote-curl.c
6da1f1a9 345) return 0;

upload-pack.c
a8d662e3 130) return readsz;
820a5361 149) BUG("packfile_uris requires sideband-all");
a8d662e3 355) send_client_data(1, output_state.buffer, output_state.used);
820a5361 1379) string_list_clear(&data->uri_protocols, 0);

wrapper.c
5efde212 70) die("Out of memory, malloc failed (tried to allocate %" PRIuMAX " bytes)",
5efde212 73) error("Out of memory, malloc failed (tried to allocate %" PRIuMAX " bytes)",

Commits introducting uncovered code:
Barret Rhoden	35e314c6 blame: add a config option to mark ignored lines
Barret Rhoden	718e473b blame: add the ability to ignore commits and their changes
Barret Rhoden	3486d8d4 Move init_skiplist() outside of fsck
Christian Couder	8b75bfd2 promisor-remote: use repository_format_partial_clone
Christian Couder	76fa09af promisor-remote: parse remote.*.partialclonefilter
Christian Couder	f51395f1 Add initial support for many promisor remotes
Christian Couder	3f82acbc Use promisor_remote_get_direct() and has_promisor_remote()
Christian Couder	e52d417b promisor-remote: implement promisor_remote_get_direct()
Dan McGregor	ba81921a http: cast result to FILE *
Denton Liu	01dc801a tag: fix formatting
Derrick Stolee	8e7e6c05 commit-graph: return with errors during write
Derrick Stolee	b1beb050 commit-graph: create new version flags
Elijah Newren	259ccb6c merge-recursive: rename merge_options argument from 'o' to 'opt'
Elijah Newren	8c8e5bd6 merge-recursive: switch directory rename detection default
Elijah Newren	e3de888c merge-recursive: rename diff_filespec 'one' to 'o'
Elijah Newren	8daec1df merge-recursive: switch from (oid,mode) pairs to a diff_filespec
Jonathan Tan	bf01639c fetch-pack: support more than one pack lockfile
Jonathan Tan	820a5361 upload-pack: send part of packfile response as uri
Jonathan Tan	a8d662e3 upload-pack: refactor reading of pack-objects out
Jonathan Tan	472fbef8 http-fetch: support fetching packfiles by URL
Josh Steadmon	6da1f1a9 protocol: advertise multiple supported versions
Junio C Hamano	1a11b378 Merge branch 'jt/fetch-cdn-offload' into pu
Martin Koegler	5efde212 zlib.c: use size_t for size
Nguyễn Thái Ngọc Duy	6f11fd5e config: add --move-to
Nguyễn Thái Ngọc Duy	a12c1ff3 config: factor out set_config_source_file()
Nguyễn Thái Ngọc Duy	8f7c7f55 config.c: add repo_config_set_worktree_gently()
Nickolai Belakovski	3da20422 ref-filter: add worktreepath atom
Phillip Wood	4b7dc0bd rebase -i: run without forking rebase--interactive
Phillip Wood	e08571cf rebase -i: use struct rebase_options in do_interactive_rebase()
Phillip Wood	33d250cd rebase -i: use struct object_id for squash_onto
Phillip Wood	21604b24 rebase -i: use struct commit when parsing options
Phillip Wood	645897ae rebase -i: remove duplication
Phillip Wood	9f6017ea rebase -i: combine rebase--interactive.c with rebase.c
Phillip Wood	4d5498a8 rebase -i: use struct rebase_options to parse args


Uncovered code in 'jch' not in 'next'
--------------------------------------------------------

attr.c
b0c2d613 1167) return 0;

builtin/blame.c
a544fb08 1005) die("no such ref: HEAD");

builtin/checkout.c
9214322b 429) die(_("neither '%s' or '%s' is specified"),
9214322b 433) die(_("'%s' must be used when '%s' is not specified"),
9214322b 442) patch_mode = "--patch=reset";
35a31cc2 446) BUG("either flag must have been set");
9214322b 520) die(_("unable to write new index file"));
1806c29f 640) BUG("'switch --orphan' should never accept a commit as starting point");
1806c29f 1023) BUG("'switch --orphan' should never accept a commit as starting point");
5c06e269 1160) die(_("only one reference expected"));
7968bef0 1284) const char *ref = to_free;
7968bef0 1286) if (skip_prefix(ref, "refs/tags/", &ref))
7968bef0 1287) die(_("a branch is expected, got tag '%s'"), ref);
7968bef0 1288) if (skip_prefix(ref, "refs/remotes/", &ref))
7968bef0 1289) die(_("a branch is expected, got remote branch '%s'"), ref);
7968bef0 1290) die(_("a branch is expected, got '%s'"), ref);
7968bef0 1298) die(_("a branch is expected, got '%s'"), branch_info->name);
c45f0f52 1313) die(_("cannot switch branch in the middle of an am session\n"
c45f0f52 1317) die(_("cannot switch branch while rebasing\n"
c45f0f52 1321) die(_("cannot switch branch while cherry-picking\n"
c45f0f52 1325) die(_("cannot switch branch while reverting\n"
c45f0f52 1329) die(_("cannot switch branch while bisecting\n"
3ec37ad1 1356) die(_("'%s' cannot be used with '%s'"), "--discard-changes", "--merge");
9736da80 1494) BUG("make up your mind, you need to take _something_");
9214322b 1523) opts->checkout_index = 0;
9214322b 1533) BUG("these flags should be non-negative by now");
9736da80 1594) die(_("could not resolve %s"), opts->from_treeish);

builtin/commit-graph.c
61df89c8 105) die_errno(_("Could not open commit-graph '%s'"), graph_name);
61df89c8 109) return 1;

builtin/difftool.c
ebe4df59 69) return error("expected object ID, got '%s'", p);
ebe4df59 73) return error("expected object ID, got '%s'", p);
20de316e 730) die(_("difftool requires worktree or --no-index"));

builtin/gc.c
bf3d70fe 126) die(_("failed to parse '%s' value '%s'"), var, value);

builtin/get-tar-commit-id.c
3548726c 40) return 1;
3548726c 42) return 1;

builtin/ls-files.c
7cb7283a 115) printf("  ctime: %u:%u\n", sd->sd_ctime.sec, sd->sd_ctime.nsec);
7cb7283a 116) printf("  mtime: %u:%u\n", sd->sd_mtime.sec, sd->sd_mtime.nsec);
7cb7283a 117) printf("  dev: %u\tino: %u\n", sd->sd_dev, sd->sd_ino);
7cb7283a 118) printf("  uid: %u\tgid: %u\n", sd->sd_uid, sd->sd_gid);
7cb7283a 119) printf("  size: %u\tflags: %x\n", sd->sd_size, ce->ce_flags);

builtin/multi-pack-index.c
467ae6f9 52) die(_("--batch-size option is only for 'repack' subcommand"));
467ae6f9 61) die(_("unrecognized subcommand: %s"), argv[0]);

builtin/pull.c
b4ad22cd 654) argv_array_push(&args, opt_cleanup);
b4ad22cd 891) BUG("expecting prefix %s, argument is %s", prefix, opt_cleanup);

builtin/rebase.c
97b27ec4 902) goto done;

builtin/remote.c
f39a9c65 1551) die(_("--save-to-push cannot be used with other options"));
f39a9c65 1575) die(_("--save-to-push can only be used when only one url is defined"));

builtin/replace.c
e640e946 383) return error(_("could not parse %s as a commit"), argv[i]);
4cc54233 490) return error(_("new commit is the same as the old one: '%s'"),

builtin/show-branch.c
7fdff474 756) read_ref_at(get_main_ref_store(the_repository),
7fdff474 769) if (read_ref_at(get_main_ref_store(the_repository),

builtin/worktree.c
722abec7 297) BUG("How come '%s' becomes empty after sanitization?", sb.buf);

commit-graph.c
61df89c8 89) close(*fd);
61df89c8 90) return 0;
93b4405f 218) error(_("commit-graph improper chunk offset %08x%08x"), (uint32_t)(chunk_offset >> 32),
93b4405f 255) error(_("commit-graph chunk id %08x appears multiple times"), chunk_id);
43d35618 315) die("dying as requested by the '%s' variable on commit-graph load!",
93b4405f 1182) graph_report(_("failed to parse commit %s from commit-graph"),
93b4405f 1248) graph_report(_("commit-graph parent list for commit %s terminates early"),
93b4405f 1253) graph_report(_("commit-graph has generation number zero for commit %s, but non-zero elsewhere"),

dir.c
84fbaa80 2320) BUG("do not know how to check file existence in arbitrary repo");

fast-import.c
28d055bd 960) && (pack_size + PACK_SIZE_THRESHOLD + s.total_out) > max_packsize)
28d055bd 1056) if ((max_packsize
28d055bd 1057) && (pack_size + PACK_SIZE_THRESHOLD + len) > max_packsize)
28d055bd 1058) || (pack_size + PACK_SIZE_THRESHOLD + len) < pack_size)
28d055bd 2071)     tmp_hex_oid_len > hexsz ||
28d055bd 2085) if (tmp_hex_oid_len == hexsz && !get_oid_hex(hex_oid, &oid)) {
7ffde293 2262) parse_cat_blob(v);
28d055bd 2566) if (!buf || size < the_hash_algo->hexsz + 6)
7ffde293 2640) parse_cat_blob(v);
28d055bd 2855) cat_blob_write(output, the_hash_algo->hexsz + 1);
28d055bd 2885) const unsigned hexsz = the_hash_algo->hexsz;
28d055bd 2920) if (size < hexsz + strlen("object ") ||
28d055bd 2925) if (size < hexsz + strlen("tree ") ||
ef479a12 2957) static void print_ls(int mode, const unsigned char *hash, const char *path)
5056bb76 3326) parse_ls(v, NULL);
7ffde293 3328) parse_cat_blob(v);
cf7b857a 3330) parse_get_mark(v);

fetch-pack.c
1e7d440b 1678) BUG("Protocol V2 does not provide shallows at this point in the fetch");

http-walker.c
2bf1db78 445) hash_to_hex(target->hash));

http.c
05dfc7ca 2094) fprintf(stderr, "Getting index for pack %s\n", hash_to_hex(hash));
048bc171 2176)     (*data == '\n' || *data == '\0')) {
05dfc7ca 2291) hash_to_hex(target->hash),
eed0e60f 2433) the_hash_algo->init_fn(&freq->c);

list-objects.c
e07c52f2 182) return;

midx.c
5bf52fbc 464) close_pack(packs->info[packs->nr].p);
5bf52fbc 465) FREE_AND_NULL(packs->info[packs->nr].p);
3c9e7185 724) BUG("object %s is in an expired pack with int-id %d",
3c9e7185 851) error(_("did not see pack-file %s to drop"),
3c9e7185 853) drop_index++;
3c9e7185 854) missing_drops++;
3c9e7185 855) i--;
3c9e7185 862) result = 1;
3c9e7185 863) goto cleanup;
3c9e7185 1180) return 0;
3c9e7185 1195) continue;
467ae6f9 1234) return 0;
19c239d4 1249) return 0;
19c239d4 1258) continue;
19c239d4 1271) continue;
19c239d4 1294) error(_("could not start pack-objects"));
19c239d4 1295) result = 1;
19c239d4 1296) goto cleanup;
19c239d4 1313) error(_("could not finish pack-objects"));
19c239d4 1314) result = 1;
19c239d4 1315) goto cleanup;

pack-bitmap.c
0dd49248 192) error("Duplicate entry in bitmap index: %s", hash_to_hex(hash));
3c9a9038 312) goto failed;

pack-revindex.c
3c9a9038 166) return -1;
3c9a9038 197) return NULL;

packfile.c
91336887 369) strbuf_release(&buf);
91336887 370) return;
b469b5aa 503) ret = p->pack_name; /* we only have a base */
3c9a9038 2066) return -1;

parse-options.c
be6ed8b8 352) die("disallowed abbreviated or ambiguous option '%.*s'",
be6ed8b8 353)     (int)(arg_end - arg), arg);

progress.c
f7c24229 126) fprintf(stderr, "  %s%-*s", counters_sb->buf,
f7c24229 129) clear_len = progress->title_len + 1 < cols ?
f7c24229 130)     cols - progress->title_len - 1 : 0;
f7c24229 131) fprintf(stderr, "%s:%*s\n  %s%s",
f7c24229 134) progress->split = 1;

read-cache.c
ee70c128 1720) if (advice_unknown_index_extension) {
ee70c128 1721) warning(_("ignoring optional %.4s index extension"), ext);
ee70c128 1722) advise(_("This is likely due to the file having been written by a newer\n"

refs.c
722abec7 111) sanitized->buf[sanitized->len-1] = '-';
722abec7 170) if (sanitized)
722abec7 171) strbuf_addch(sanitized, '-');
722abec7 173) return -1;
722abec7 178) strbuf_complete(sanitized, '/');
722abec7 215) BUG("sanitizing refname '%s' check returned error", refname);
56700903 700)  refs_reflog_exists(refs, ref))

remote-curl.c
9c9492e8 1123) else if (!*q)

revision.c
8320b1db 956) prio_queue_put(queue, p);

sequencer.c
f2feeefc 535) warning(_("invalid cleanup mode %s, falling back to default"), cleanup_arg);
8805d809 536) return use_editor ? def->editor :
8805d809 550) BUG("invalid cleanup_mode provided (%d)", cleanup_mode);
f59199d5 2741) res |= git_config_set_in_file_gently(opts_file,
f59199d5 2772) res |= git_config_set_in_file_gently(opts_file,
f59199d5 2773) "options.gpg-sign", opts->gpg_sign);

server-info.c
b263625a 148) } else if (line.buf[0] == 'D') {
b263625a 151) } else if (line.buf[0] == 'T') {
6d11084f 153) goto out_stale;

sha1-file.c
95399788 198) return GIT_HASH_UNKNOWN;

sha1-name.c
93645957 1219) object = deref_tag(cb->repo, object, path,
e5a01a84 1387) BUG("sorry get_merge_bases() can't take struct repository yet");

trace2.c
88b21890 448) tr2tls_create_self(thread_name, us_now);

trace2/tr2_dst.c
2b87cf9d 16) const char *env_value = tr2_sysenv_get(TR2_SYSENV_DST_DEBUG);
a4d3a283 45) sid = last_slash + 1;
a4d3a283 55) strbuf_setlen(&path, base_path_len);
a4d3a283 56) strbuf_addf(&path, ".%d", attempt_count);
a4d3a283 65) if (tr2_dst_want_warning())
a4d3a283 66) warning("trace2: could not open '%.*s' for '%s' tracing: %s",
f72a481b 69) strerror(errno));
a4d3a283 71) tr2_dst_trace_disable(dst);
a4d3a283 72) strbuf_release(&path);
a4d3a283 73) return 0;
2b87cf9d 93) strerror(errno));
2b87cf9d 301) warning("unable to write trace to '%s': %s",

trace2/tr2_sid.c
ffe10ef1 31) xsnprintf(hostname, sizeof(hostname), "localhost");

trace2/tr2_sysenv.c
2b87cf9d 50) return 0;
2b87cf9d 60) return 0;
2b87cf9d 96) BUG("tr2_sysenv_get invalid var '%d'", var);
2b87cf9d 114) const char *tr2_sysenv_display_name(enum tr2_sysenv_variable var)
2b87cf9d 116) if (var >= TR2_SYSENV_MUST_BE_LAST)
2b87cf9d 117) BUG("tr2_sysenv_get invalid var '%d'", var);
2b87cf9d 119) return tr2_sysenv_settings[var].env_var_name;

trace2/tr2_tgt_event.c
2b87cf9d 56) tr2env_event_max_nesting_levels = max_nesting;
2b87cf9d 61) tr2env_event_be_brief = want_brief;
2b87cf9d 542) if (ctx->nr_open_regions <= tr2env_event_max_nesting_levels) {

unpack-trees.c
191e9d2c 1699) return add_rejected_path(o, error_type, ce->name);
b165fac8 2346) return o->quiet ? -1 :

Commits introducting uncovered code:
Ævar Arnfjörð Bjarmason	61df89c8 commit-graph: don't early exit(1) on e.g. "git status"
Ævar Arnfjörð Bjarmason	93b4405f commit-graph: improve & i18n error messages
Ævar Arnfjörð Bjarmason	bf3d70fe gc: handle & check gc.reflogExpire config
Ævar Arnfjörð Bjarmason	43d35618 commit-graph write: don't die if the existing graph is corrupt
brian m. carlson	eed0e60f http: compute hash of downloaded objects using the_hash_algo
brian m. carlson	05dfc7ca http: replace sha1_to_hex
brian m. carlson	2bf1db78 http-walker: replace sha1_to_hex
brian m. carlson	ef479a12 fast-import: replace sha1_to_hex
brian m. carlson	28d055bd fast-import: make hash-size independent
brian m. carlson	0dd49248 pack-bitmap: replace sha1_to_hex
brian m. carlson	95399788 hash: add a function to lookup hash algorithm by length
brian m. carlson	9c9492e8 remote-curl: make hash size independent
brian m. carlson	ebe4df59 builtin/difftool: use parse_oid_hex
Christian Couder	e640e946 replace: fix --graft when passing a tag as parent
Christian Couder	4cc54233 replace: fix --graft when passing a tag first
Denton Liu	8805d809 sequencer.c: define describe_cleanup_mode
Denton Liu	f2feeefc sequencer.c: remove duplicate code
Denton Liu	b4ad22cd merge: cleanup messages like commit
Denton Liu	97b27ec4 rebase: fast-forward --onto in more cases
Denton Liu	f39a9c65 remote: add --save-to-push option to git remote set-url
Derrick Stolee	19c239d4 midx: implement midx_repack()
Derrick Stolee	5bf52fbc midx: refactor permutation logic and pack sorting
Derrick Stolee	467ae6f9 multi-pack-index: prepare 'repack' subcommand
Derrick Stolee	91336887 repack: refactor pack deletion for future use
Derrick Stolee	3c9e7185 multi-pack-index: implement 'expire' subcommand
Elijah Newren	cf7b857a fast-import: fix erroneous handling of get-mark with empty orphan commits
Elijah Newren	7ffde293 fast-import: only allow cat-blob requests where it makes sense
Elijah Newren	5056bb76 fast-import: check most prominent commands first
Jeff Hostetler	88b21890 trace2: refactor setting process starting time
Jeff Hostetler	2b87cf9d trace2: use system config for default trace2 settings
Jeff Hostetler	ffe10ef1 trace2: make SIDs more unique
Jeff King	6d11084f server-info: fix blind pointer arithmetic
Jeff King	b263625a server-info: use strbuf to read old info/packs file
Jeff King	b469b5aa packfile: fix pack basename computation
Jeff King	048bc171 http: simplify parsing of remote objects/info/packs
Jeff King	3c9a9038 pack-revindex: open index if necessary
Jeff King	8320b1db revision: use a prio_queue to hold rewritten parents
Johannes Schindelin	20de316e difftool: allow running outside Git worktrees with --no-index
Johannes Schindelin	be6ed8b8 tests: disallow the use of abbreviated options (by default)
Jonathan Nieder	ee70c128 index: offer advice for unknown index extensions
Jonathan Tan	1e7d440b fetch-pack: call prepare_shallow_info only if v0
Josh Steadmon	a4d3a283 trace2: write to directory targets
Josh Steadmon	e07c52f2 rev-list: exclude promisor objects at walk time
Junio C Hamano	f72a481b Merge branch 'jh/trace2-sid-fix' into jch
Nguyễn Thái Ngọc Duy	56700903 refs.c: add repo_dwim_log()
Nguyễn Thái Ngọc Duy	93645957 sha1-name.c: remove the_repo from handle_one_ref()
Nguyễn Thái Ngọc Duy	e5a01a84 sha1-name.c: remove the_repo from get_oid_mb()
Nguyễn Thái Ngọc Duy	b0c2d613 Introduce "precious" file concept
Nguyễn Thái Ngọc Duy	191e9d2c unpack-trees: keep gently check inside add_rejected_path
Nguyễn Thái Ngọc Duy	9214322b restore: add --worktree and --index
Nguyễn Thái Ngọc Duy	35a31cc2 restore: support --patch
Nguyễn Thái Ngọc Duy	1806c29f switch: make --orphan switch to an empty tree
Nguyễn Thái Ngọc Duy	5c06e269 switch: stop accepting pathspec
Nguyễn Thái Ngọc Duy	7968bef0 switch: only allow explicit detached HEAD
Nguyễn Thái Ngọc Duy	c45f0f52 switch: reject if some operation is in progress
Nguyễn Thái Ngọc Duy	3ec37ad1 switch: add --discard-changes
Nguyễn Thái Ngọc Duy	7fdff474 refs.c: remove the_repo from read_ref_at()
Nguyễn Thái Ngọc Duy	722abec7 worktree add: sanitize worktree names
Nguyễn Thái Ngọc Duy	84fbaa80 sha1-name.c: remove the_repo from diagnose_invalid_index_path()
Nguyễn Thái Ngọc Duy	9736da80 restore: take tree-ish from --source option instead
Nguyễn Thái Ngọc Duy	b165fac8 unpack-trees: rename "gently" flag to "quiet"
Phillip Wood	f59199d5 sequencer: break some long lines
Rene Scharfe	3548726c get-tar-commit-id: parse comment record
SZEDER Gábor	f7c24229 progress: break too long progress bar lines
SZEDER Gábor	a544fb08 blame: default to HEAD in a bare repo when no start commit is given
Thomas Gummerer	7cb7283a ls-files: use correct format string


Uncovered code in 'next' not in 'master'
--------------------------------------------------------

builtin/log.c
7954d365 254) static int estimate_commit_count(struct commit_list *list)
7954d365 292) int n = estimate_commit_count(list);
7954d365 336) static void setup_early_output(void)
7954d365 367) int n = estimate_commit_count(rev->commits);
7954d365 379) setup_early_output();
bc208ae3 520) die(_("not a valid object name %s"), obj_name);
bc208ae3 544) return error(_("could not read object %s"), oid_to_hex(oid));
bc208ae3 663) ret = error(_("unknown type: %d"), o->type);
bc208ae3 918) die(_("need exactly one range"));
bc208ae3 928) die(_("not a range"));
bc208ae3 1051) die(_("cover letter needs email format"));
bc208ae3 1221) die(_("two output directories?"));
bc208ae3 1332) die(_("unknown commit %s"), base_commit);
bc208ae3 1342) die(_("failed to resolve '%s' as a valid ref"), upstream);
bc208ae3 1351) die(_("failed to get upstream, if you want to record base commit automatically,\n"
bc208ae3 1371) die(_("failed to find exact merge base"));
bc208ae3 1750) die_errno(_("could not create directory '%s'"),
bc208ae3 1952) die(_("failed to create output files"));
bc208ae3 2076) die(_("unknown commit %s"), head);
bc208ae3 2078) die(_("unknown commit %s"), upstream);
bc208ae3 2090) die(_("unknown commit %s"), limit);

builtin/rebase--interactive.c
1ba204de 17) static int add_exec_commands(struct string_list *commands)
1ba204de 19) const char *todo_file = rebase_path_todo();
1ba204de 20) struct todo_list todo_list = TODO_LIST_INIT;
1ba204de 23) if (strbuf_read_file(&todo_list.buf, todo_file, 0) < 0)
1ba204de 24) return error_errno(_("could not read '%s'."), todo_file);
1ba204de 26) if (todo_list_parse_insn_buffer(the_repository, todo_list.buf.buf,
1ba204de 28) todo_list_release(&todo_list);
1ba204de 29) return error(_("unusable todo list: '%s'"), todo_file);
1ba204de 32) todo_list_add_exec_commands(&todo_list, commands);
1ba204de 33) res = todo_list_write_to_file(the_repository, &todo_list,
1ba204de 35) todo_list_release(&todo_list);
1ba204de 37) if (res)
1ba204de 38) return error_errno(_("could not write '%s'."), todo_file);
1ba204de 39) return 0;
79d7e883 42) static int rearrange_squash_in_todo_file(void)
79d7e883 44) const char *todo_file = rebase_path_todo();
79d7e883 45) struct todo_list todo_list = TODO_LIST_INIT;
79d7e883 46) int res = 0;
79d7e883 48) if (strbuf_read_file(&todo_list.buf, todo_file, 0) < 0)
79d7e883 49) return error_errno(_("could not read '%s'."), todo_file);
79d7e883 50) if (todo_list_parse_insn_buffer(the_repository, todo_list.buf.buf,
79d7e883 52) todo_list_release(&todo_list);
79d7e883 53) return error(_("unusable todo list: '%s'"), todo_file);
79d7e883 56) res = todo_list_rearrange_squash(&todo_list);
79d7e883 57) if (!res)
79d7e883 58) res = todo_list_write_to_file(the_repository, &todo_list,
79d7e883 61) todo_list_release(&todo_list);
79d7e883 63) if (res)
79d7e883 64) return error_errno(_("could not write '%s'."), todo_file);
79d7e883 65) return 0;
ed35d188 75) return error_errno(_("could not read '%s'."), todo_file);
ed35d188 79) todo_list_release(&todo_list);
ed35d188 80) return error(_("unusable todo list: '%s'"), todo_file);
ed35d188 88) return error_errno(_("could not write '%s'."), todo_file);
a930eb03 100) return error_errno(_("could not read '%s'."), todo_file);
a930eb03 106) res = error_errno(_("could not write '%s'"), todo_file);
94bcad79 208) BUG("unusable todo list");
79d7e883 366) ret = rearrange_squash_in_todo_file();
1ba204de 369) ret = add_exec_commands(&commands);

builtin/stash.c
8a0fc8d1 127) die(_("'%s' is not a stash-like commit"), revision);
8a0fc8d1 160) free_stash_info(info);
8a0fc8d1 161) fprintf_ln(stderr, _("No stash entries found."));
8a0fc8d1 162) return -1;
8a0fc8d1 197) free_stash_info(info);
4e2dd393 224) return error(_("git stash clear with parameters is "
8a0fc8d1 240) return -1;
8a0fc8d1 248) return -1;
8a0fc8d1 264) return error(_("unable to write new index file"));
8a0fc8d1 372) remove_path(stash_index_path.buf);
8a0fc8d1 373) return -1;
8a0fc8d1 400) return -1;
8a0fc8d1 403) return error(_("cannot apply a stash in the middle of a merge"));
8a0fc8d1 413) strbuf_release(&out);
8a0fc8d1 414) return error(_("could not generate diff %s^!."),
8a0fc8d1 421) return error(_("conflicts in index."
8a0fc8d1 427) return error(_("could not save index tree"));
8a0fc8d1 434) return error(_("could not restore untracked files from stash"));
8a0fc8d1 465) return -1;
8a0fc8d1 470) strbuf_release(&out);
8a0fc8d1 475) strbuf_release(&out);
8a0fc8d1 476) return -1;
4e2dd393 552) return error(_("%s: Could not drop stash entry"),
c4de61d7 627) printf_ln(_("The stash entry is kept in case "
dc7bd382 761) free_stash_info(&info);
40af1468 762) usage_with_options(git_stash_show_usage, options);
41e0dd55 782) stash_msg = "Created via \"git stash store\".";
41e0dd55 788) if (!quiet) {
41e0dd55 789) fprintf_ln(stderr, _("Cannot update %s with %s"),
41e0dd55 792) return -1;
41e0dd55 816) if (!quiet)
41e0dd55 817) fprintf_ln(stderr, _("\"git stash store\" requires one "
41e0dd55 819) return -1;
d4788af8 902) return -1;
d4788af8 967) ret = -1;
d4788af8 968) goto done;
d4788af8 973) ret = -1;
d4788af8 974) goto done;
d4788af8 979) ret = -1;
d4788af8 980) goto done;
d4788af8 1006) ret = -1;
d4788af8 1007) goto done;
d4788af8 1018) ret = -1;
d4788af8 1019) goto done;
d4788af8 1025) ret = -1;
d4788af8 1026) goto done;
d4788af8 1033) ret = -1;
d4788af8 1034) goto done;
d4788af8 1072) ret = -1;
d4788af8 1073) goto done;
d4788af8 1079) ret = -1;
d4788af8 1080) goto done;
d4788af8 1091) ret = -1;
d4788af8 1092) goto done;
d4788af8 1097) ret = -1;
d4788af8 1098) goto done;
1ac528c0 1135) fprintf_ln(stderr, _("You do not have "
d4788af8 1144) ret = 1;
d4788af8 1145) goto done;
1ac528c0 1161) if (!quiet)
1ac528c0 1162) fprintf_ln(stderr, _("Cannot save the current "
d4788af8 1164) ret = -1;
d4788af8 1165) goto done;
1ac528c0 1170) if (!quiet)
1ac528c0 1171) fprintf_ln(stderr, _("Cannot save "
d4788af8 1173) ret = -1;
d4788af8 1174) goto done;
1ac528c0 1181) if (!quiet)
1ac528c0 1182) fprintf_ln(stderr, _("Cannot save the current "
d4788af8 1184) goto done;
1ac528c0 1218) if (!quiet)
1ac528c0 1219) fprintf_ln(stderr, _("Cannot record "
d4788af8 1221) ret = -1;
d4788af8 1222) goto done;
d553f538 1293) ret = -1;
d553f538 1294) goto done;
d553f538 1304) ret = -1;
1ac528c0 1305) if (!quiet)
1ac528c0 1306) fprintf_ln(stderr, _("Cannot initialize stash"));
d553f538 1307) goto done;
d553f538 1319) ret = -1;
1ac528c0 1320) if (!quiet)
1ac528c0 1321) fprintf_ln(stderr, _("Cannot save the current status"));
d553f538 1322) goto done;
d553f538 1339) ret = -1;
d553f538 1359) ret = -1;
d553f538 1360) goto done;
d553f538 1369) ret = -1;
d553f538 1370) goto done;
d553f538 1378) ret = -1;
d553f538 1387) ret = -1;
d553f538 1398) ret = -1;
d553f538 1399) goto done;
d553f538 1408) ret = -1;
d553f538 1409) goto done;
d553f538 1417) ret = -1;
d553f538 1443) ret = -1;
7906af0c 1536) return env;
90a46272 1564) const char *path = mkpath("%s/git-legacy-stash",
90a46272 1567) if (sane_execvp(path, (char **)argv) < 0)
90a46272 1568) die_errno(_("could not exec %s"), path);
90a46272 1570) BUG("sane_execvp() returned???");
40af1468 1611) usage_msg_opt(xstrfmt(_("unknown subcommand: %s"), argv[0]),
40af1468 1639) continue;

diff-no-index.c
16bb3d71 263) warning(_("Not a git repository. Use --no-index to "
16bb3d71 299) return 1;

diff.c
d2d3f273 4805) return error(_("unknown change class '%c' in --diff-filter=%s"),
5a749d9f 4829) return error(_("unknown value after ws-error-highlight=%.*s"),
a75f28cb 4843) return error(_("unable to resolve '%s'"), arg);
59311a98 4923) options->color_moved = COLOR_MOVED_NO;
bb987290 4945) options->color_moved_ws_handling = 0;
bb987290 4946) return 0;
10f35b1c 4983) static int diff_opt_diff_algorithm(const struct option *opt,
10f35b1c 4986) struct diff_options *options = opt->value;
10f35b1c 4987) long value = parse_algorithm_value(arg);
10f35b1c 4989) BUG_ON_OPT_NEG(unset);
10f35b1c 4990) if (value < 0)
10f35b1c 4991) return error(_("option diff-algorithm accepts \"myers\", "
10f35b1c 4995) DIFF_XDL_CLR(options, NEED_MINIMAL);
10f35b1c 4996) options->xdl_opts &= ~XDF_DIFF_ALGORITHM_MASK;
10f35b1c 4997) options->xdl_opts |= value;
10f35b1c 4998) return 0;
125dcea9 5185) return error(_("failed to parse --submodule option parameter: '%s'"),
e9fb39b6 5239) return error(_("bad --word-diff argument: %s"), arg);

help.c
057ab54b 389) if (sb.buf[0] == '-')
057ab54b 390) string_list_remove(list, sb.buf + 1, 0);

parse-options-cb.c
d8774183 26) v = the_hash_algo->hexsz;

parse-options.c
5205749d 526) static int show_gitcomp(const struct option *opts)
5205749d 605) return show_gitcomp(options);

progress.c
9d81ecb5 243) struct progress *start_delayed_sparse_progress(const char *title,
9d81ecb5 246) return start_progress_delay(title, total, 2, 1);

protocol.c
8cbeba06 38) die("unknown value for %s: %s", git_test_k, git_test_v);

rebase-interactive.c
6ca89c6f 26) warning(_("unrecognized setting %s for option "
a930eb03 105) return error_errno(_("could not write '%s'"), todo_file);
a930eb03 108) return error(_("could not copy '%s' to '%s'."), todo_file,
6ca89c6f 167) goto leave_check;

remote-curl.c
ed8b4132 157) die(_("invalid quoting in push-option value: '%s'"), value);
4814acf6 355) die(_("invalid server response; expected service, got flush packet"));
ed8b4132 446) die(_("repository '%s' not found"),
c1284b21 447)     transport_anonymize_url(url.buf));
4814acf6 584) die(_("shouldn't have EOF when not gentle on EOF"));
ed8b4132 664) error(_("unable to rewind rpc post data - try increasing http.postBuffer"));
ed8b4132 764) die(_("cannot handle pushes this big"));
ed8b4132 879) die(_("cannot deflate request; zlib deflate error %d"), ret);
ed8b4132 883) die(_("cannot deflate request; zlib end error %d"), ret);
ed8b4132 1014) die(_("dumb http transport does not support shallow capabilities"));
ed8b4132 1076) die(_("cannot fetch by sha1 over smart http"));
ed8b4132 1119) die(_("protocol error: expected sha/ref, got %s'"), p);
ed8b4132 1125) die(_("protocol error: expected sha/ref, got %s'"), p);
ed8b4132 1137) die(_("http transport does not support %s"), buf->buf);
ed8b4132 1251) die(_("http transport does not support %s"), buf->buf);
ed8b4132 1359) error(_("remote-curl: usage: git remote-curl <remote> [<url>]"));
ed8b4132 1391) error(_("remote-curl: error reading command stream from git"));
ed8b4132 1398) die(_("remote-curl: fetch attempted without a local repo"));
ed8b4132 1438) error(_("remote-curl: unknown command '%s' from git"), buf.buf);

sequencer.c
616d7740 4619) strbuf_addstr(buf, " -c");
87805600 4666) res = -1;
6ca89c6f 4667) goto out;
6ca89c6f 4672) goto out;
6ca89c6f 4681) fprintf(stderr, _(edit_todo_list_advice));
6bfeb7f1 4797) todo_list_release(&new_todo);
94bcad79 4803) todo_list_release(&new_todo);
94bcad79 4804) return error_errno(_("could not write '%s'"), todo_file);

strbuf.c
5ef264db 259) die("`pos' is too far after the end of the buffer");
5ef264db 264) BUG("your vsnprintf is broken (returned %d)", len);
5ef264db 266) return; /* nothing to do */
5ef264db 268) die("you want to use way too much memory");
5ef264db 276) BUG("your vsnprintf is broken (returns inconsistent lengths)");

Commits introducting uncovered code:
Alban Gruin	6bfeb7f1 sequencer: refactor skip_unnecessary_picks() to work on a todo_list
Alban Gruin	6ca89c6f sequencer: refactor check_todo_list() to work on a todo_list
Alban Gruin	1ba204de rebase--interactive: move sequencer_add_exec_commands()
Alban Gruin	79d7e883 rebase--interactive: move rearrange_squash_in_todo_file()
Alban Gruin	ed35d188 rebase--interactive: move transform_todo_file()
Alban Gruin	a930eb03 rebase-interactive: rewrite edit_todo_list() to handle the initial edit
Alban Gruin	94bcad79 sequencer: change complete_action() to use the refactored functions
Alban Gruin	616d7740 sequencer: introduce todo_list_write_to_file()
Jeff Hostetler	9d81ecb5 progress: add sparse mode to force 100% complete message
Jeff King	5205749d parse-options: drop unused ctx parameter from show_gitcomp()
Jeff King	7954d365 log: drop unused rev_info from early output
Jeff King	057ab54b completion: fix multiple command removals
Joel Teichroeb	8a0fc8d1 stash: convert apply to builtin
Joel Teichroeb	4e2dd393 stash: convert drop and clear to builtin
Joel Teichroeb	c4de61d7 stash: convert pop to builtin
Johannes Schindelin	c1284b21 curl: anonymize URLs in error messages and warnings
Johannes Schindelin	ed8b4132 remote-curl: mark all error messages for translation
Johannes Schindelin	7906af0c tests: add a special setup where stash.useBuiltin is off
Johannes Schindelin	90a46272 stash: optionally use the scripted version again
Jonathan Tan	8cbeba06 tests: define GIT_TEST_PROTOCOL_VERSION
Junio C Hamano	4814acf6 Merge branch 'js/remote-curl-i18n' into next
Junio C Hamano	bc208ae3 builtin/log: downcase the beginning of error messages
Nguyễn Thái Ngọc Duy	d8774183 diff-parseopt: convert --[no-]abbrev
Nguyễn Thái Ngọc Duy	e9fb39b6 diff-parseopt: convert --word-diff
Nguyễn Thái Ngọc Duy	125dcea9 diff-parseopt: convert --submodule
Nguyễn Thái Ngọc Duy	d2d3f273 diff-parseopt: convert --diff-filter
Nguyễn Thái Ngọc Duy	bb987290 diff.c: allow --no-color-moved-ws
Nguyễn Thái Ngọc Duy	59311a98 diff-parseopt: convert --[no-]color-moved
Nguyễn Thái Ngọc Duy	a75f28cb diff-parseopt: convert --find-object
Nguyễn Thái Ngọc Duy	5a749d9f diff-parseopt: convert --ws-error-highlight
Nguyễn Thái Ngọc Duy	16bb3d71 diff --no-index: use parse_options() instead of diff_opt_parse()
Nguyễn Thái Ngọc Duy	10f35b1c diff-parseopt: convert --diff-algorithm
Paul-Sebastian Ungureanu	d553f538 stash: convert push to builtin
Paul-Sebastian Ungureanu	1ac528c0 stash: make push -q quiet
Paul-Sebastian Ungureanu	d4788af8 stash: convert create to builtin
Paul-Sebastian Ungureanu	41e0dd55 stash: convert store to builtin
Paul-Sebastian Ungureanu	40af1468 stash: convert `stash--helper.c` into `stash.c`
Paul-Sebastian Ungureanu	dc7bd382 stash: convert show to builtin
Paul-Sebastian Ungureanu	5ef264db strbuf.c: add `strbuf_insertf()` and `strbuf_vinsertf()`
René Scharfe	87805600 sequencer: factor out strbuf_read_file_or_whine()


Uncovered code in 'master' not in 'master@{1}'
--------------------------------------------------------

builtin/branch.c
0ecb1fc7 452) die(_("could not resolve HEAD"));
0ecb1fc7 458) die(_("HEAD (%s) points outside of refs/heads/"), refname);

builtin/checkout.c
091e04bc 303) return;
091e04bc 1283) die(_("'%s' cannot be used with switching branches"),

builtin/commit-tree.c
cbdeab98 56) die(_("not a valid object name %s"), arg);
cbdeab98 71) strbuf_addch(buf, '\n');
cbdeab98 78) static int parse_file_arg_callback(const struct option *opt,
cbdeab98 82) struct strbuf *buf = opt->value;
cbdeab98 84) BUG_ON_OPT_NEG_NOARG(unset, arg);
cbdeab98 86) if (buf->len)
cbdeab98 87) strbuf_addch(buf, '\n');
cbdeab98 88) if (!strcmp(arg, "-"))
cbdeab98 89) fd = 0;
cbdeab98 91) fd = open(arg, O_RDONLY);
cbdeab98 92) if (fd < 0)
cbdeab98 93) die_errno(_("git commit-tree: failed to open '%s'"), arg);
cbdeab98 95) if (strbuf_read(buf, fd, 0) < 0)
cbdeab98 96) die_errno(_("git commit-tree: failed to read '%s'"), arg);
cbdeab98 97) if (fd && close(fd))
cbdeab98 98) die_errno(_("git commit-tree: failed to close '%s'"), arg);
cbdeab98 100) return 0;
cbdeab98 133) die(_("must give exactly one tree"));
cbdeab98 140) die_errno(_("git commit-tree: failed to read"));

builtin/fsck.c
8d8c2a5a 271) static int mark_packed_unreachable_referents(const struct object_id *oid,
8d8c2a5a 276) mark_unreachable_referents(oid);
8d8c2a5a 277) return 0;

builtin/prune-packed.c
9b0bd87e 67) usage_msg_opt(_("too many arguments"),

builtin/prune.c
d55a30bb 43) progress = start_delayed_progress(_("Checking connectivity"), 0);

builtin/rebase.c
cbd29ead 470) } else if (old_orig)
cbd29ead 471) delete_ref(NULL, "ORIG_HEAD", old_orig, 0);
b3a5d5a8 1233) if (is_interactive(&options))
b3a5d5a8 1234) trace2_cmd_mode("interactive");
b3a5d5a8 1235) else if (exec.nr)
b3a5d5a8 1236) trace2_cmd_mode("interactive-exec");
b3a5d5a8 1238) trace2_cmd_mode(action_names[action]);

builtin/worktree.c
7af01f23 302) die_errno(_("could not create directory of '%s'"),

combine-diff.c
d76ce4f7 89)     filename_changed(p->parent[j].status))
d76ce4f7 90) strbuf_release(&p->parent[j].path);
d76ce4f7 992) dump_quoted_path("--- ", "", "/dev/null",
d76ce4f7 1000) dump_quoted_path("--- ", "", "/dev/null",
d76ce4f7 1273) write_name_quoted(p->path, stdout,

diff.c
84b5089e 4741) count = strtoul(end+1, &end, 10);
84b5089e 4743) return error(_("invalid --stat value: %s"), value);
84b5089e 4748) return error(_("%s expects a numerical value"),
84b5089e 4753) return error(_("%s expects a numerical value"),
84b5089e 4758) return error(_("%s expects a numerical value"),
84b5089e 4763) return error(_("%s expects a numerical value"),
84b5089e 4766) BUG("%s should not get here", opt->long_name);
ced4e179 4921) else if (*arg != '/')
ced4e179 4922) return error(_("%s expects <n>/<m> form"), opt->long_name);
ced4e179 4924) arg++;
ced4e179 4925) opt2 = parse_rename_score(&arg);
ced4e179 4928) return error(_("%s expects <n>/<m> form"), opt->long_name);
af2f3680 4940) return error(_("%s expects a character, got '%s'"),
7d7942b7 4953) options->flags.stat_with_summary = 0;
4ce7aab5 4969) BUG("how come --cumulative take a value?");
7f64850d 4987) return error(_("invalid argument to %s"), opt->long_name);
f476308b 5007) return error(_("invalid argument to %s"), opt->long_name);
d473e2e0 5052) return error(_("%s expects a numerical value"), "--unified");

entry.c
536ec183 450) BUG("Can't remove entry to a path");

fetch-pack.c
37c80012 196) die_errno(_("unable to write to remote"));
37c80012 1169) die_errno(_("unable to write request to remote"));

git.c
ee4512ed 155) trace2_cmd_name("_query_");
ee4512ed 159) trace2_cmd_name("_query_");
ee4512ed 163) trace2_cmd_name("_query_");

ident.c
39ab4d09 452) break;
39ab4d09 454) name = getenv("GIT_AUTHOR_NAME");
39ab4d09 455) email = getenv("GIT_AUTHOR_EMAIL");
39ab4d09 456) break;
39ab4d09 515) return config_error_nonbool(var);
39ab4d09 525) return config_error_nonbool(var);
39ab4d09 535) return config_error_nonbool(var);
39ab4d09 545) return config_error_nonbool(var);

pack-objects.c
c409d108 122) void oe_map_new_pack(struct packing_data *pack)

pager.c
eee73d1d 103) pager_process->trace2_child_class = "pager";

parse-options.c
f62470c6 116) BUG("BITOP can't have unset form");
3ebbe289 255) rc = (*numopt->ll_callback)(p, numopt, arg, 0);
3ebbe289 432) BUG("OPTION_CALLBACK needs one callback");
3ebbe289 434) BUG("OPTION_CALLBACK can't have two callbacks");
bf3ff338 438) BUG("OPTION_LOWLEVEL_CALLBACK needs a callback");
bf3ff338 440) BUG("OPTION_LOWLEVEL_CALLBACK needs no high level callback");
202fbb33 475) BUG("Can't keep argv0 if you don't have it");
f41179f1 622) BUG("parse_short_opt() cannot return these");
f41179f1 647) BUG("parse_short_opt() cannot return these");
f41179f1 676) BUG("parse_long_opt() cannot return these");

pkt-line.c
37c80012 92) die_errno(_("unable to write flush packet"));
37c80012 99) die_errno(_("unable to write delim packet"));

pretty.c
4f732e0f 1079) return 0;
4f732e0f 1116) return 0;

reachable.c
fde67d68 162) static void *lookup_object_by_type(struct repository *r,
fde67d68 166) switch (type) {
fde67d68 168) return lookup_commit(r, oid);
fde67d68 170) return lookup_tree(r, oid);
fde67d68 172) return lookup_tag(r, oid);
fde67d68 174) return lookup_blob(r, oid);
fde67d68 176) die("BUG: unknown object type %d", type);
fde67d68 180) static int mark_object_seen(const struct object_id *oid,
fde67d68 187) struct object *obj = lookup_object_by_type(the_repository, oid, type);
fde67d68 188) if (!obj)
fde67d68 189) die("unable to create object '%s'", oid_to_hex(oid));
fde67d68 191) obj->flags |= SEEN;
fde67d68 192) return 0;
fde67d68 228) traverse_bitmap_commit_list(bitmap_git, mark_object_seen);
fde67d68 229) free_bitmap_index(bitmap_git);
fde67d68 230) return;

remote-curl.c
a97d0079 577) die("shouldn't have EOF when not gentle on EOF");
a97d0079 608) BUG("The entire rpc->buf should be larger than LARGE_PACKET_MAX");
a97d0079 1297) rpc.protocol_header = NULL;
a97d0079 1298) strbuf_release(&buf);
a97d0079 1325) BUG("The entire rpc->buf should be larger than LARGE_PACKET_MAX");

revision.c
d76ce4f7 2654) die("--combined-all-paths makes no sense without -c or --cc");

run-command.c
ee4512ed 239) int ec = errno;
ee4512ed 240) trace2_exec_result(exec_id, ec);
ee4512ed 241) errno = ec;
ee4512ed 997) int ret = wait_or_whine(cmd->pid, cmd->argv[0], 1);
ee4512ed 998) trace2_child_exit(cmd, ret);
ee4512ed 999) return ret;
ee4512ed 1021) int run_command_v_opt_tr2(const char **argv, int opt, const char *tr2_class)
ee4512ed 1023) return run_command_v_opt_cd_env_tr2(argv, opt, NULL, NULL, tr2_class);

strbuf.c
fd2015b3 397) return 0;

t/helper/test-trace2.c
a15860dc 24) return MyError;
a15860dc 28) return MyError;
a15860dc 52) die("expect <exit_code>");
a15860dc 72) die("expect <exit_code>");
a15860dc 92) die("expect <error_message>");
a15860dc 142) return 0;
a15860dc 169) static int ut_005exec(int argc, const char **argv)
a15860dc 173) if (!argc)
a15860dc 174) return 0;
a15860dc 176) result = execv_git_cmd(argv);
a15860dc 177) return result;
a15860dc 186) die("%s", usage_error);
a15860dc 191) die("%s", usage_error);
a15860dc 227) static int print_usage(void)
a15860dc 232) fprintf(stderr, "usage:\n");
a15860dc 233) for_each_ut (k, ut_k)
a15860dc 234) fprintf(stderr, "\t%s %s %s\n", USAGE_PREFIX, ut_k->ut_name,
a15860dc 237) return 129;
a15860dc 272) return print_usage();

trace2.c
ee4512ed 127) static void tr2main_signal_handler(int signo)
ee4512ed 134) us_now = getnanotime() / 1000;
ee4512ed 135) us_elapsed_absolute = tr2tls_absolute_elapsed(us_now);
ee4512ed 137) for_each_wanted_builtin (j, tgt_j)
ee4512ed 138) if (tgt_j->pfn_signal)
ee4512ed 139) tgt_j->pfn_signal(us_elapsed_absolute, signo);
ee4512ed 141) sigchain_pop(signo);
ee4512ed 142) raise(signo);
ee4512ed 143) }
ee4512ed 151) return;
ee4512ed 232) void trace2_cmd_path_fl(const char *file, int line, const char *pathname)
ee4512ed 237) if (!trace2_enabled)
ee4512ed 238) return;
ee4512ed 240) for_each_wanted_builtin (j, tgt_j)
ee4512ed 241) if (tgt_j->pfn_command_path_fl)
ee4512ed 242) tgt_j->pfn_command_path_fl(file, line, pathname);
ee4512ed 270) for_each_wanted_builtin (j, tgt_j)
ee4512ed 271) if (tgt_j->pfn_command_mode_fl)
ee4512ed 272) tgt_j->pfn_command_mode_fl(file, line, mode);
ee4512ed 284) for_each_wanted_builtin (j, tgt_j)
ee4512ed 285) if (tgt_j->pfn_alias_fl)
ee4512ed 286) tgt_j->pfn_alias_fl(file, line, alias, argv);
ee4512ed 303) tr2_cfg_set_fl(file, line, key, value);
ee4512ed 347) us_elapsed_child = 0;
ee4512ed 370) us_now = getnanotime() / 1000;
ee4512ed 371) us_elapsed_absolute = tr2tls_absolute_elapsed(us_now);
ee4512ed 373) exec_id = tr2tls_locked_increment(&tr2_next_exec_id);
ee4512ed 375) for_each_wanted_builtin (j, tgt_j)
ee4512ed 376) if (tgt_j->pfn_exec_fl)
ee4512ed 377) tgt_j->pfn_exec_fl(file, line, us_elapsed_absolute,
ee4512ed 380) return exec_id;
ee4512ed 383) void trace2_exec_result_fl(const char *file, int line, int exec_id, int code)
ee4512ed 390) if (!trace2_enabled)
ee4512ed 391) return;
ee4512ed 393) us_now = getnanotime() / 1000;
ee4512ed 394) us_elapsed_absolute = tr2tls_absolute_elapsed(us_now);
ee4512ed 396) for_each_wanted_builtin (j, tgt_j)
ee4512ed 397) if (tgt_j->pfn_exec_result_fl)
ee4512ed 398) tgt_j->pfn_exec_result_fl(
ee4512ed 402) void trace2_thread_start_fl(const char *file, int line, const char *thread_name)
ee4512ed 409) if (!trace2_enabled)
ee4512ed 410) return;
ee4512ed 412) if (tr2tls_is_main_thread()) {
ee4512ed 422) trace2_region_enter_printf_fl(file, line, NULL, NULL, NULL,
ee4512ed 425) return;
ee4512ed 428) us_now = getnanotime() / 1000;
ee4512ed 429) us_elapsed_absolute = tr2tls_absolute_elapsed(us_now);
ee4512ed 431) tr2tls_create_self(thread_name);
ee4512ed 433) for_each_wanted_builtin (j, tgt_j)
ee4512ed 434) if (tgt_j->pfn_thread_start_fl)
ee4512ed 435) tgt_j->pfn_thread_start_fl(file, line,
ee4512ed 439) void trace2_thread_exit_fl(const char *file, int line)
ee4512ed 447) if (!trace2_enabled)
ee4512ed 448) return;
ee4512ed 450) if (tr2tls_is_main_thread()) {
ee4512ed 461) trace2_region_leave_printf_fl(file, line, NULL, NULL, NULL,
ee4512ed 463) return;
ee4512ed 466) us_now = getnanotime() / 1000;
ee4512ed 467) us_elapsed_absolute = tr2tls_absolute_elapsed(us_now);
ee4512ed 474) tr2tls_pop_unwind_self();
ee4512ed 475) us_elapsed_thread = tr2tls_region_elasped_self(us_now);
ee4512ed 477) for_each_wanted_builtin (j, tgt_j)
ee4512ed 478) if (tgt_j->pfn_thread_exit_fl)
ee4512ed 479) tgt_j->pfn_thread_exit_fl(file, line,
ee4512ed 483) tr2tls_unset_self();
ee4512ed 493) return;
ee4512ed 508) if (repo->trace2_repo_id)
ee4512ed 509) return;
ee4512ed 511) repo->trace2_repo_id = tr2tls_locked_increment(&tr2_next_repo_id);
ee4512ed 513) for_each_wanted_builtin (j, tgt_j)
ee4512ed 514) if (tgt_j->pfn_repo_fl)
ee4512ed 515) tgt_j->pfn_repo_fl(file, line, repo);
ee4512ed 531) us_now = getnanotime() / 1000;
ee4512ed 532) us_elapsed_absolute = tr2tls_absolute_elapsed(us_now);
ee4512ed 541) for_each_wanted_builtin (j, tgt_j)
ee4512ed 542) if (tgt_j->pfn_region_enter_printf_va_fl)
ee4512ed 543) tgt_j->pfn_region_enter_printf_va_fl(
ee4512ed 547) tr2tls_push_self(us_now);
ee4512ed 598) us_now = getnanotime() / 1000;
ee4512ed 599) us_elapsed_absolute = tr2tls_absolute_elapsed(us_now);
ee4512ed 607) us_elapsed_region = tr2tls_region_elasped_self(us_now);
ee4512ed 609) tr2tls_pop_self();
ee4512ed 615) for_each_wanted_builtin (j, tgt_j)
ee4512ed 616) if (tgt_j->pfn_region_leave_printf_va_fl)
ee4512ed 617) tgt_j->pfn_region_leave_printf_va_fl(
ee4512ed 668) return;
ee4512ed 690) strbuf_addf(&buf_string, "%" PRIdMAX, value);
ee4512ed 691) trace2_data_string_fl(file, line, category, repo, key, buf_string.buf);
ee4512ed 692) strbuf_release(&buf_string);
ee4512ed 695) void trace2_data_json_fl(const char *file, int line, const char *category,
ee4512ed 705) if (!trace2_enabled)
ee4512ed 706) return;
ee4512ed 708) us_now = getnanotime() / 1000;
ee4512ed 709) us_elapsed_absolute = tr2tls_absolute_elapsed(us_now);
ee4512ed 710) us_elapsed_region = tr2tls_region_elasped_self(us_now);
ee4512ed 712) for_each_wanted_builtin (j, tgt_j)
ee4512ed 713) if (tgt_j->pfn_data_fl)
ee4512ed 714) tgt_j->pfn_data_json_fl(file, line, us_elapsed_absolute,
ee4512ed 719) void trace2_printf_va_fl(const char *file, int line, const char *fmt,
ee4512ed 727) if (!trace2_enabled)
ee4512ed 728) return;
ee4512ed 730) us_now = getnanotime() / 1000;
ee4512ed 731) us_elapsed_absolute = tr2tls_absolute_elapsed(us_now);
ee4512ed 737) for_each_wanted_builtin (j, tgt_j)
ee4512ed 738) if (tgt_j->pfn_printf_va_fl)
ee4512ed 739) tgt_j->pfn_printf_va_fl(file, line, us_elapsed_absolute,
ee4512ed 743) void trace2_printf_fl(const char *file, int line, const char *fmt, ...)
ee4512ed 747) va_start(ap, fmt);
ee4512ed 748) trace2_printf_va_fl(file, line, fmt, ap);
ee4512ed 749) va_end(ap);
ee4512ed 750) }

trace2/tr2_cfg.c
ee4512ed 21) return tr2_cfg_count_patterns;
ee4512ed 33) strbuf_setlen(buf, buf->len - 1);
ee4512ed 83) void tr2_cfg_set_fl(const char *file, int line, const char *key,
ee4512ed 86) struct tr2_cfg_data data = { file, line };
ee4512ed 88) if (tr2_cfg_load_patterns() > 0)
ee4512ed 89) tr2_cfg_cb(key, value, &data);
ee4512ed 90) }

trace2/tr2_dst.c
ee4512ed 15) static int tr2_dst_want_warning(void)
ee4512ed 19) if (tr2env_dst_debug == -1) {
ee4512ed 20) const char *env_value = getenv(TR2_ENVVAR_DST_DEBUG);
ee4512ed 21) if (!env_value || !*env_value)
ee4512ed 22) tr2env_dst_debug = 0;
ee4512ed 24) tr2env_dst_debug = atoi(env_value) > 0;
ee4512ed 27) return tr2env_dst_debug;
ee4512ed 43) if (tr2_dst_want_warning())
ee4512ed 44) warning("trace2: could not open '%s' for '%s' tracing: %s",
ee4512ed 45) tgt_value, dst->env_var_name, strerror(errno));
ee4512ed 47) tr2_dst_trace_disable(dst);
ee4512ed 48) return 0;
ee4512ed 63) static int tr2_dst_try_uds_connect(const char *path, int sock_type, int *out_fd)
ee4512ed 68) fd = socket(AF_UNIX, sock_type, 0);
ee4512ed 69) if (fd == -1)
ee4512ed 70) return errno;
ee4512ed 72) sa.sun_family = AF_UNIX;
ee4512ed 73) strlcpy(sa.sun_path, path, sizeof(sa.sun_path));
ee4512ed 75) if (connect(fd, (struct sockaddr *)&sa, sizeof(sa)) == -1) {
ee4512ed 76) int e = errno;
ee4512ed 77) close(fd);
ee4512ed 78) return e;
ee4512ed 81) *out_fd = fd;
ee4512ed 82) return 0;
ee4512ed 88) static int tr2_dst_try_unix_domain_socket(struct tr2_dst *dst,
ee4512ed 91) unsigned int uds_try = 0;
ee4512ed 94) const char *path = NULL;
ee4512ed 107) if (skip_prefix(tgt_value, PREFIX_AF_UNIX_STREAM, &path))
ee4512ed 108) uds_try |= TR2_DST_UDS_TRY_STREAM;
ee4512ed 110) else if (skip_prefix(tgt_value, PREFIX_AF_UNIX_DGRAM, &path))
ee4512ed 111) uds_try |= TR2_DST_UDS_TRY_DGRAM;
ee4512ed 113) else if (skip_prefix(tgt_value, PREFIX_AF_UNIX, &path))
ee4512ed 114) uds_try |= TR2_DST_UDS_TRY_STREAM | TR2_DST_UDS_TRY_DGRAM;
ee4512ed 116) if (!path || !*path) {
ee4512ed 117) if (tr2_dst_want_warning())
ee4512ed 118) warning("trace2: invalid AF_UNIX value '%s' for '%s' tracing",
ee4512ed 121) tr2_dst_trace_disable(dst);
ee4512ed 122) return 0;
ee4512ed 125) if (!is_absolute_path(path) ||
ee4512ed 126)     strlen(path) >= sizeof(((struct sockaddr_un *)0)->sun_path)) {
ee4512ed 127) if (tr2_dst_want_warning())
ee4512ed 128) warning("trace2: invalid AF_UNIX path '%s' for '%s' tracing",
ee4512ed 131) tr2_dst_trace_disable(dst);
ee4512ed 132) return 0;
ee4512ed 135) if (uds_try & TR2_DST_UDS_TRY_STREAM) {
ee4512ed 136) e = tr2_dst_try_uds_connect(path, SOCK_STREAM, &fd);
ee4512ed 137) if (!e)
ee4512ed 138) goto connected;
ee4512ed 139) if (e != EPROTOTYPE)
ee4512ed 140) goto error;
ee4512ed 142) if (uds_try & TR2_DST_UDS_TRY_DGRAM) {
ee4512ed 143) e = tr2_dst_try_uds_connect(path, SOCK_DGRAM, &fd);
ee4512ed 144) if (!e)
ee4512ed 145) goto connected;
ee4512ed 149) if (tr2_dst_want_warning())
ee4512ed 150) warning("trace2: could not connect to socket '%s' for '%s' tracing: %s",
ee4512ed 153) tr2_dst_trace_disable(dst);
ee4512ed 154) return 0;
ee4512ed 157) dst->fd = fd;
ee4512ed 158) dst->need_close = 1;
ee4512ed 159) dst->initialized = 1;
ee4512ed 161) return dst->fd;
ee4512ed 165) static void tr2_dst_malformed_warning(struct tr2_dst *dst,
ee4512ed 168) struct strbuf buf = STRBUF_INIT;
ee4512ed 170) strbuf_addf(&buf, "trace2: unknown value for '%s': '%s'",
ee4512ed 172) warning("%s", buf.buf);
ee4512ed 174) strbuf_release(&buf);
ee4512ed 175) }
ee4512ed 196) dst->fd = STDERR_FILENO;
ee4512ed 197) return dst->fd;
ee4512ed 201) dst->fd = atoi(tgt_value);
ee4512ed 202) return dst->fd;
ee4512ed 209) if (starts_with(tgt_value, PREFIX_AF_UNIX))
ee4512ed 210) return tr2_dst_try_unix_domain_socket(dst, tgt_value);
ee4512ed 214) tr2_dst_malformed_warning(dst, tgt_value);
ee4512ed 215) tr2_dst_trace_disable(dst);
ee4512ed 216) return 0;
ee4512ed 248) if (tr2_dst_want_warning())
ee4512ed 249) warning("unable to write trace to '%s': %s", dst->env_var_name,
ee4512ed 250) strerror(errno));
ee4512ed 251) tr2_dst_trace_disable(dst);

trace2/tr2_sid.c
ee4512ed 27) return;
ee4512ed 59) tr2_sid_compute();

trace2/tr2_tgt_event.c
ee4512ed 57) tr2env_event_nesting_wanted = want_nesting;
ee4512ed 61) tr2env_event_brief = want_brief;
ee4512ed 96)     !strcmp(event_name, "atexit")) {
ee4512ed 158) static void fn_signal(uint64_t us_elapsed_absolute, int signo)
ee4512ed 160) const char *event_name = "signal";
ee4512ed 161) struct json_writer jw = JSON_WRITER_INIT;
ee4512ed 162) double t_abs = (double)us_elapsed_absolute / 1000000.0;
ee4512ed 164) jw_object_begin(&jw, 0);
ee4512ed 165) event_fmt_prepare(event_name, __FILE__, __LINE__, NULL, &jw);
ee4512ed 166) jw_object_double(&jw, "t_abs", 6, t_abs);
ee4512ed 167) jw_object_intmax(&jw, "signo", signo);
ee4512ed 168) jw_end(&jw);
ee4512ed 170) tr2_dst_write_line(&tr2dst_event, &jw.json);
ee4512ed 171) jw_release(&jw);
ee4512ed 172) }
ee4512ed 206) if (fmt && *fmt) {
ee4512ed 207) jw_object_string(jw, field_name, fmt);
ee4512ed 208) return;
ee4512ed 235) static void fn_command_path_fl(const char *file, int line, const char *pathname)
ee4512ed 237) const char *event_name = "cmd_path";
ee4512ed 238) struct json_writer jw = JSON_WRITER_INIT;
ee4512ed 240) jw_object_begin(&jw, 0);
ee4512ed 241) event_fmt_prepare(event_name, file, line, NULL, &jw);
ee4512ed 242) jw_object_string(&jw, "path", pathname);
ee4512ed 243) jw_end(&jw);
ee4512ed 245) tr2_dst_write_line(&tr2dst_event, &jw.json);
ee4512ed 246) jw_release(&jw);
ee4512ed 247) }
ee4512ed 266) static void fn_command_mode_fl(const char *file, int line, const char *mode)
ee4512ed 268) const char *event_name = "cmd_mode";
ee4512ed 269) struct json_writer jw = JSON_WRITER_INIT;
ee4512ed 271) jw_object_begin(&jw, 0);
ee4512ed 272) event_fmt_prepare(event_name, file, line, NULL, &jw);
ee4512ed 273) jw_object_string(&jw, "name", mode);
ee4512ed 274) jw_end(&jw);
ee4512ed 276) tr2_dst_write_line(&tr2dst_event, &jw.json);
ee4512ed 277) jw_release(&jw);
ee4512ed 278) }
ee4512ed 280) static void fn_alias_fl(const char *file, int line, const char *alias,
ee4512ed 283) const char *event_name = "alias";
ee4512ed 284) struct json_writer jw = JSON_WRITER_INIT;
ee4512ed 286) jw_object_begin(&jw, 0);
ee4512ed 287) event_fmt_prepare(event_name, file, line, NULL, &jw);
ee4512ed 288) jw_object_string(&jw, "alias", alias);
ee4512ed 289) jw_object_inline_begin_array(&jw, "argv");
ee4512ed 290) jw_array_argv(&jw, argv);
ee4512ed 291) jw_end(&jw);
ee4512ed 292) jw_end(&jw);
ee4512ed 294) tr2_dst_write_line(&tr2dst_event, &jw.json);
ee4512ed 295) jw_release(&jw);
ee4512ed 296) }
ee4512ed 309) jw_object_string(&jw, "child_class", "hook");
ee4512ed 310) jw_object_string(&jw, "hook_name", cmd->trace2_hook_name);
ee4512ed 317) jw_object_string(&jw, "cd", cmd->dir);
ee4512ed 321) jw_array_string(&jw, "git");
ee4512ed 351) static void fn_thread_start_fl(const char *file, int line,
ee4512ed 354) const char *event_name = "thread_start";
ee4512ed 355) struct json_writer jw = JSON_WRITER_INIT;
ee4512ed 357) jw_object_begin(&jw, 0);
ee4512ed 358) event_fmt_prepare(event_name, file, line, NULL, &jw);
ee4512ed 359) jw_end(&jw);
ee4512ed 361) tr2_dst_write_line(&tr2dst_event, &jw.json);
ee4512ed 362) jw_release(&jw);
ee4512ed 363) }
ee4512ed 365) static void fn_thread_exit_fl(const char *file, int line,
ee4512ed 369) const char *event_name = "thread_exit";
ee4512ed 370) struct json_writer jw = JSON_WRITER_INIT;
ee4512ed 371) double t_rel = (double)us_elapsed_thread / 1000000.0;
ee4512ed 373) jw_object_begin(&jw, 0);
ee4512ed 374) event_fmt_prepare(event_name, file, line, NULL, &jw);
ee4512ed 375) jw_object_double(&jw, "t_rel", 6, t_rel);
ee4512ed 376) jw_end(&jw);
ee4512ed 378) tr2_dst_write_line(&tr2dst_event, &jw.json);
ee4512ed 379) jw_release(&jw);
ee4512ed 380) }
ee4512ed 382) static void fn_exec_fl(const char *file, int line, uint64_t us_elapsed_absolute,
ee4512ed 385) const char *event_name = "exec";
ee4512ed 386) struct json_writer jw = JSON_WRITER_INIT;
ee4512ed 388) jw_object_begin(&jw, 0);
ee4512ed 389) event_fmt_prepare(event_name, file, line, NULL, &jw);
ee4512ed 390) jw_object_intmax(&jw, "exec_id", exec_id);
ee4512ed 391) if (exe)
ee4512ed 392) jw_object_string(&jw, "exe", exe);
ee4512ed 393) jw_object_inline_begin_array(&jw, "argv");
ee4512ed 394) jw_array_argv(&jw, argv);
ee4512ed 395) jw_end(&jw);
ee4512ed 396) jw_end(&jw);
ee4512ed 398) tr2_dst_write_line(&tr2dst_event, &jw.json);
ee4512ed 399) jw_release(&jw);
ee4512ed 400) }
ee4512ed 402) static void fn_exec_result_fl(const char *file, int line,
ee4512ed 406) const char *event_name = "exec_result";
ee4512ed 407) struct json_writer jw = JSON_WRITER_INIT;
ee4512ed 409) jw_object_begin(&jw, 0);
ee4512ed 410) event_fmt_prepare(event_name, file, line, NULL, &jw);
ee4512ed 411) jw_object_intmax(&jw, "exec_id", exec_id);
ee4512ed 412) jw_object_intmax(&jw, "code", code);
ee4512ed 413) jw_end(&jw);
ee4512ed 415) tr2_dst_write_line(&tr2dst_event, &jw.json);
ee4512ed 416) jw_release(&jw);
ee4512ed 417) }
ee4512ed 435) static void fn_repo_fl(const char *file, int line,
ee4512ed 438) const char *event_name = "def_repo";
ee4512ed 439) struct json_writer jw = JSON_WRITER_INIT;
ee4512ed 441) jw_object_begin(&jw, 0);
ee4512ed 442) event_fmt_prepare(event_name, file, line, repo, &jw);
ee4512ed 443) jw_object_string(&jw, "worktree", repo->worktree);
ee4512ed 444) jw_end(&jw);
ee4512ed 446) tr2_dst_write_line(&tr2dst_event, &jw.json);
ee4512ed 447) jw_release(&jw);
ee4512ed 448) }
ee4512ed 450) static void fn_region_enter_printf_va_fl(const char *file, int line,
ee4512ed 457) const char *event_name = "region_enter";
ee4512ed 458) struct tr2tls_thread_ctx *ctx = tr2tls_get_self();
ee4512ed 459) if (ctx->nr_open_regions <= tr2env_event_nesting_wanted) {
ee4512ed 460) struct json_writer jw = JSON_WRITER_INIT;
ee4512ed 462) jw_object_begin(&jw, 0);
ee4512ed 463) event_fmt_prepare(event_name, file, line, repo, &jw);
ee4512ed 464) jw_object_intmax(&jw, "nesting", ctx->nr_open_regions);
ee4512ed 465) if (category)
ee4512ed 466) jw_object_string(&jw, "category", category);
ee4512ed 467) if (label)
ee4512ed 468) jw_object_string(&jw, "label", label);
ee4512ed 469) maybe_add_string_va(&jw, "msg", fmt, ap);
ee4512ed 470) jw_end(&jw);
ee4512ed 472) tr2_dst_write_line(&tr2dst_event, &jw.json);
ee4512ed 473) jw_release(&jw);
ee4512ed 475) }
ee4512ed 477) static void fn_region_leave_printf_va_fl(
ee4512ed 482) const char *event_name = "region_leave";
ee4512ed 483) struct tr2tls_thread_ctx *ctx = tr2tls_get_self();
ee4512ed 484) if (ctx->nr_open_regions <= tr2env_event_nesting_wanted) {
ee4512ed 485) struct json_writer jw = JSON_WRITER_INIT;
ee4512ed 486) double t_rel = (double)us_elapsed_region / 1000000.0;
ee4512ed 488) jw_object_begin(&jw, 0);
ee4512ed 489) event_fmt_prepare(event_name, file, line, repo, &jw);
ee4512ed 490) jw_object_double(&jw, "t_rel", 6, t_rel);
ee4512ed 491) jw_object_intmax(&jw, "nesting", ctx->nr_open_regions);
ee4512ed 492) if (category)
ee4512ed 493) jw_object_string(&jw, "category", category);
ee4512ed 494) if (label)
ee4512ed 495) jw_object_string(&jw, "label", label);
ee4512ed 496) maybe_add_string_va(&jw, "msg", fmt, ap);
ee4512ed 497) jw_end(&jw);
ee4512ed 499) tr2_dst_write_line(&tr2dst_event, &jw.json);
ee4512ed 500) jw_release(&jw);
ee4512ed 502) }
ee4512ed 531) static void fn_data_json_fl(const char *file, int line,
ee4512ed 537) const char *event_name = "data_json";
ee4512ed 538) struct tr2tls_thread_ctx *ctx = tr2tls_get_self();
ee4512ed 539) if (ctx->nr_open_regions <= tr2env_event_nesting_wanted) {
ee4512ed 540) struct json_writer jw = JSON_WRITER_INIT;
ee4512ed 541) double t_abs = (double)us_elapsed_absolute / 1000000.0;
ee4512ed 542) double t_rel = (double)us_elapsed_region / 1000000.0;
ee4512ed 544) jw_object_begin(&jw, 0);
ee4512ed 545) event_fmt_prepare(event_name, file, line, repo, &jw);
ee4512ed 546) jw_object_double(&jw, "t_abs", 6, t_abs);
ee4512ed 547) jw_object_double(&jw, "t_rel", 6, t_rel);
ee4512ed 548) jw_object_intmax(&jw, "nesting", ctx->nr_open_regions);
ee4512ed 549) jw_object_string(&jw, "category", category);
ee4512ed 550) jw_object_string(&jw, "key", key);
ee4512ed 551) jw_object_sub_jw(&jw, "value", value);
ee4512ed 552) jw_end(&jw);
ee4512ed 554) tr2_dst_write_line(&tr2dst_event, &jw.json);
ee4512ed 555) jw_release(&jw);
ee4512ed 557) }

trace2/tr2_tgt_normal.c
ee4512ed 105) static void fn_signal(uint64_t us_elapsed_absolute, int signo)
ee4512ed 107) struct strbuf buf_payload = STRBUF_INIT;
ee4512ed 108) double elapsed = (double)us_elapsed_absolute / 1000000.0;
ee4512ed 110) strbuf_addf(&buf_payload, "signal elapsed:%.6f code:%d", elapsed,
ee4512ed 112) normal_io_write_fl(__FILE__, __LINE__, &buf_payload);
ee4512ed 113) strbuf_release(&buf_payload);
ee4512ed 114) }
ee4512ed 138) if (fmt && *fmt) {
ee4512ed 139) strbuf_addstr(buf, fmt);
ee4512ed 140) return;
ee4512ed 155) static void fn_command_path_fl(const char *file, int line, const char *pathname)
ee4512ed 157) struct strbuf buf_payload = STRBUF_INIT;
ee4512ed 159) strbuf_addf(&buf_payload, "cmd_path %s", pathname);
ee4512ed 160) normal_io_write_fl(file, line, &buf_payload);
ee4512ed 161) strbuf_release(&buf_payload);
ee4512ed 162) }
ee4512ed 176) static void fn_command_mode_fl(const char *file, int line, const char *mode)
ee4512ed 178) struct strbuf buf_payload = STRBUF_INIT;
ee4512ed 180) strbuf_addf(&buf_payload, "cmd_mode %s", mode);
ee4512ed 181) normal_io_write_fl(file, line, &buf_payload);
ee4512ed 182) strbuf_release(&buf_payload);
ee4512ed 183) }
ee4512ed 185) static void fn_alias_fl(const char *file, int line, const char *alias,
ee4512ed 188) struct strbuf buf_payload = STRBUF_INIT;
ee4512ed 190) strbuf_addf(&buf_payload, "alias %s ->", alias);
ee4512ed 191) sq_quote_argv_pretty(&buf_payload, argv);
ee4512ed 192) normal_io_write_fl(file, line, &buf_payload);
ee4512ed 193) strbuf_release(&buf_payload);
ee4512ed 194) }
ee4512ed 196) static void fn_child_start_fl(const char *file, int line,
ee4512ed 200) struct strbuf buf_payload = STRBUF_INIT;
ee4512ed 202) strbuf_addf(&buf_payload, "child_start[%d] ", cmd->trace2_child_id);
ee4512ed 204) if (cmd->dir) {
ee4512ed 205) strbuf_addstr(&buf_payload, " cd");
ee4512ed 206) sq_quote_buf_pretty(&buf_payload, cmd->dir);
ee4512ed 207) strbuf_addstr(&buf_payload, "; ");
ee4512ed 215) if (cmd->git_cmd)
ee4512ed 216) strbuf_addstr(&buf_payload, "git");
ee4512ed 217) sq_quote_argv_pretty(&buf_payload, cmd->argv);
ee4512ed 219) normal_io_write_fl(file, line, &buf_payload);
ee4512ed 220) strbuf_release(&buf_payload);
ee4512ed 221) }
ee4512ed 223) static void fn_child_exit_fl(const char *file, int line,
ee4512ed 227) struct strbuf buf_payload = STRBUF_INIT;
ee4512ed 228) double elapsed = (double)us_elapsed_child / 1000000.0;
ee4512ed 230) strbuf_addf(&buf_payload, "child_exit[%d] pid:%d code:%d elapsed:%.6f",
ee4512ed 232) normal_io_write_fl(file, line, &buf_payload);
ee4512ed 233) strbuf_release(&buf_payload);
ee4512ed 234) }
ee4512ed 236) static void fn_exec_fl(const char *file, int line, uint64_t us_elapsed_absolute,
ee4512ed 239) struct strbuf buf_payload = STRBUF_INIT;
ee4512ed 241) strbuf_addf(&buf_payload, "exec[%d] ", exec_id);
ee4512ed 242) if (exe)
ee4512ed 243) strbuf_addstr(&buf_payload, exe);
ee4512ed 244) sq_quote_argv_pretty(&buf_payload, argv);
ee4512ed 245) normal_io_write_fl(file, line, &buf_payload);
ee4512ed 246) strbuf_release(&buf_payload);
ee4512ed 247) }
ee4512ed 249) static void fn_exec_result_fl(const char *file, int line,
ee4512ed 253) struct strbuf buf_payload = STRBUF_INIT;
ee4512ed 255) strbuf_addf(&buf_payload, "exec_result[%d] code:%d", exec_id, code);
ee4512ed 256) if (code > 0)
ee4512ed 257) strbuf_addf(&buf_payload, " err:%s", strerror(code));
ee4512ed 258) normal_io_write_fl(file, line, &buf_payload);
ee4512ed 259) strbuf_release(&buf_payload);
ee4512ed 260) }
ee4512ed 262) static void fn_param_fl(const char *file, int line, const char *param,
ee4512ed 265) struct strbuf buf_payload = STRBUF_INIT;
ee4512ed 267) strbuf_addf(&buf_payload, "def_param %s=%s", param, value);
ee4512ed 268) normal_io_write_fl(file, line, &buf_payload);
ee4512ed 269) strbuf_release(&buf_payload);
ee4512ed 270) }
ee4512ed 272) static void fn_repo_fl(const char *file, int line,
ee4512ed 275) struct strbuf buf_payload = STRBUF_INIT;
ee4512ed 277) strbuf_addstr(&buf_payload, "worktree ");
ee4512ed 278) sq_quote_buf_pretty(&buf_payload, repo->worktree);
ee4512ed 279) normal_io_write_fl(file, line, &buf_payload);
ee4512ed 280) strbuf_release(&buf_payload);
ee4512ed 281) }
ee4512ed 283) static void fn_printf_va_fl(const char *file, int line,
ee4512ed 287) struct strbuf buf_payload = STRBUF_INIT;
ee4512ed 289) maybe_append_string_va(&buf_payload, fmt, ap);
ee4512ed 290) normal_io_write_fl(file, line, &buf_payload);
ee4512ed 291) strbuf_release(&buf_payload);
ee4512ed 292) }

trace2/tr2_tgt_perf.c
ee4512ed 102) strbuf_addf(buf, "r%d ", repo->trace2_repo_id);
ee4512ed 125) strbuf_addbuf(buf, &dots);
ee4512ed 126) len_indent -= dots.len;
ee4512ed 187) static void fn_signal(uint64_t us_elapsed_absolute, int signo)
ee4512ed 189) const char *event_name = "signal";
ee4512ed 190) struct strbuf buf_payload = STRBUF_INIT;
ee4512ed 192) strbuf_addf(&buf_payload, "signo:%d", signo);
ee4512ed 194) perf_io_write_fl(__FILE__, __LINE__, event_name, NULL,
ee4512ed 196) strbuf_release(&buf_payload);
ee4512ed 197) }
ee4512ed 223) if (fmt && *fmt) {
ee4512ed 224) strbuf_addstr(buf, fmt);
ee4512ed 225) return;
ee4512ed 242) static void fn_command_path_fl(const char *file, int line, const char *pathname)
ee4512ed 244) const char *event_name = "cmd_path";
ee4512ed 245) struct strbuf buf_payload = STRBUF_INIT;
ee4512ed 247) strbuf_addstr(&buf_payload, pathname);
ee4512ed 249) perf_io_write_fl(file, line, event_name, NULL, NULL, NULL, NULL,
ee4512ed 251) strbuf_release(&buf_payload);
ee4512ed 252) }
ee4512ed 269) static void fn_command_mode_fl(const char *file, int line, const char *mode)
ee4512ed 271) const char *event_name = "cmd_mode";
ee4512ed 272) struct strbuf buf_payload = STRBUF_INIT;
ee4512ed 274) strbuf_addstr(&buf_payload, mode);
ee4512ed 276) perf_io_write_fl(file, line, event_name, NULL, NULL, NULL, NULL,
ee4512ed 278) strbuf_release(&buf_payload);
ee4512ed 279) }
ee4512ed 281) static void fn_alias_fl(const char *file, int line, const char *alias,
ee4512ed 284) const char *event_name = "alias";
ee4512ed 285) struct strbuf buf_payload = STRBUF_INIT;
ee4512ed 287) strbuf_addf(&buf_payload, "alias:%s argv:", alias);
ee4512ed 288) sq_quote_argv_pretty(&buf_payload, argv);
ee4512ed 290) perf_io_write_fl(file, line, event_name, NULL, NULL, NULL, NULL,
ee4512ed 292) strbuf_release(&buf_payload);
ee4512ed 293) }
ee4512ed 303) strbuf_addf(&buf_payload, "[ch%d] class:hook hook:%s",
ee4512ed 313) strbuf_addstr(&buf_payload, " cd:");
ee4512ed 314) sq_quote_buf_pretty(&buf_payload, cmd->dir);
ee4512ed 319) strbuf_addstr(&buf_payload, " git");
ee4512ed 341) static void fn_thread_start_fl(const char *file, int line,
ee4512ed 344) const char *event_name = "thread_start";
ee4512ed 345) struct strbuf buf_payload = STRBUF_INIT;
ee4512ed 347) perf_io_write_fl(file, line, event_name, NULL, &us_elapsed_absolute,
ee4512ed 349) strbuf_release(&buf_payload);
ee4512ed 350) }
ee4512ed 352) static void fn_thread_exit_fl(const char *file, int line,
ee4512ed 356) const char *event_name = "thread_exit";
ee4512ed 357) struct strbuf buf_payload = STRBUF_INIT;
ee4512ed 359) perf_io_write_fl(file, line, event_name, NULL, &us_elapsed_absolute,
ee4512ed 361) strbuf_release(&buf_payload);
ee4512ed 362) }
ee4512ed 364) static void fn_exec_fl(const char *file, int line, uint64_t us_elapsed_absolute,
ee4512ed 367) const char *event_name = "exec";
ee4512ed 368) struct strbuf buf_payload = STRBUF_INIT;
ee4512ed 370) strbuf_addf(&buf_payload, "id:%d ", exec_id);
ee4512ed 371) strbuf_addstr(&buf_payload, "argv:");
ee4512ed 372) if (exe)
ee4512ed 373) strbuf_addf(&buf_payload, " %s", exe);
ee4512ed 374) sq_quote_argv_pretty(&buf_payload, argv);
ee4512ed 376) perf_io_write_fl(file, line, event_name, NULL, &us_elapsed_absolute,
ee4512ed 378) strbuf_release(&buf_payload);
ee4512ed 379) }
ee4512ed 381) static void fn_exec_result_fl(const char *file, int line,
ee4512ed 385) const char *event_name = "exec_result";
ee4512ed 386) struct strbuf buf_payload = STRBUF_INIT;
ee4512ed 388) strbuf_addf(&buf_payload, "id:%d code:%d", exec_id, code);
ee4512ed 389) if (code > 0)
ee4512ed 390) strbuf_addf(&buf_payload, " err:%s", strerror(code));
ee4512ed 392) perf_io_write_fl(file, line, event_name, NULL, &us_elapsed_absolute,
ee4512ed 394) strbuf_release(&buf_payload);
ee4512ed 395) }
ee4512ed 397) static void fn_param_fl(const char *file, int line, const char *param,
ee4512ed 400) const char *event_name = "def_param";
ee4512ed 401) struct strbuf buf_payload = STRBUF_INIT;
ee4512ed 403) strbuf_addf(&buf_payload, "%s:%s", param, value);
ee4512ed 405) perf_io_write_fl(file, line, event_name, NULL, NULL, NULL, NULL,
ee4512ed 407) strbuf_release(&buf_payload);
ee4512ed 408) }
ee4512ed 410) static void fn_repo_fl(const char *file, int line,
ee4512ed 413) const char *event_name = "def_repo";
ee4512ed 414) struct strbuf buf_payload = STRBUF_INIT;
ee4512ed 416) strbuf_addstr(&buf_payload, "worktree:");
ee4512ed 417) sq_quote_buf_pretty(&buf_payload, repo->worktree);
ee4512ed 419) perf_io_write_fl(file, line, event_name, repo, NULL, NULL, NULL,
ee4512ed 421) strbuf_release(&buf_payload);
ee4512ed 422) }
ee4512ed 424) static void fn_region_enter_printf_va_fl(const char *file, int line,
ee4512ed 431) const char *event_name = "region_enter";
ee4512ed 432) struct strbuf buf_payload = STRBUF_INIT;
ee4512ed 434) if (label)
ee4512ed 435) strbuf_addf(&buf_payload, "label:%s ", label);
ee4512ed 436) maybe_append_string_va(&buf_payload, fmt, ap);
ee4512ed 438) perf_io_write_fl(file, line, event_name, repo, &us_elapsed_absolute,
ee4512ed 440) strbuf_release(&buf_payload);
ee4512ed 441) }
ee4512ed 443) static void fn_region_leave_printf_va_fl(
ee4512ed 448) const char *event_name = "region_leave";
ee4512ed 449) struct strbuf buf_payload = STRBUF_INIT;
ee4512ed 451) if (label)
ee4512ed 452) strbuf_addf(&buf_payload, "label:%s ", label);
ee4512ed 453) maybe_append_string_va(&buf_payload, fmt, ap);
ee4512ed 455) perf_io_write_fl(file, line, event_name, repo, &us_elapsed_absolute,
ee4512ed 457) strbuf_release(&buf_payload);
ee4512ed 458) }
ee4512ed 460) static void fn_data_fl(const char *file, int line, uint64_t us_elapsed_absolute,
ee4512ed 465) const char *event_name = "data";
ee4512ed 466) struct strbuf buf_payload = STRBUF_INIT;
ee4512ed 468) strbuf_addf(&buf_payload, "%s:%s", key, value);
ee4512ed 470) perf_io_write_fl(file, line, event_name, repo, &us_elapsed_absolute,
ee4512ed 472) strbuf_release(&buf_payload);
ee4512ed 473) }
ee4512ed 475) static void fn_data_json_fl(const char *file, int line,
ee4512ed 481) const char *event_name = "data_json";
ee4512ed 482) struct strbuf buf_payload = STRBUF_INIT;
ee4512ed 484) strbuf_addf(&buf_payload, "%s:%s", key, value->json.buf);
ee4512ed 486) perf_io_write_fl(file, line, event_name, repo, &us_elapsed_absolute,
ee4512ed 488) strbuf_release(&buf_payload);
ee4512ed 489) }
ee4512ed 491) static void fn_printf_va_fl(const char *file, int line,
ee4512ed 495) const char *event_name = "printf";
ee4512ed 496) struct strbuf buf_payload = STRBUF_INIT;
ee4512ed 498) maybe_append_string_va(&buf_payload, fmt, ap);
ee4512ed 500) perf_io_write_fl(file, line, event_name, NULL, &us_elapsed_absolute,
ee4512ed 502) strbuf_release(&buf_payload);
ee4512ed 503) }

trace2/tr2_tls.c
ee4512ed 38) strbuf_addf(&ctx->thread_name, "th%02d:", ctx->thread_id);
ee4512ed 41) strbuf_setlen(&ctx->thread_name, TR2_MAX_THREAD_NAME);
ee4512ed 58) ctx = tr2tls_create_self("unknown");
ee4512ed 63) int tr2tls_is_main_thread(void)
ee4512ed 65) struct tr2tls_thread_ctx *ctx = pthread_getspecific(tr2tls_key);
ee4512ed 67) return ctx == tr2tls_thread_main;
ee4512ed 82) void tr2tls_push_self(uint64_t us_now)
ee4512ed 84) struct tr2tls_thread_ctx *ctx = tr2tls_get_self();
ee4512ed 86) ALLOC_GROW(ctx->array_us_start, ctx->nr_open_regions + 1, ctx->alloc);
ee4512ed 87) ctx->array_us_start[ctx->nr_open_regions++] = us_now;
ee4512ed 88) }
ee4512ed 90) void tr2tls_pop_self(void)
ee4512ed 92) struct tr2tls_thread_ctx *ctx = tr2tls_get_self();
ee4512ed 94) if (!ctx->nr_open_regions)
ee4512ed 95) BUG("no open regions in thread '%s'", ctx->thread_name.buf);
ee4512ed 97) ctx->nr_open_regions--;
ee4512ed 98) }
ee4512ed 105) tr2tls_pop_self();
ee4512ed 115) return 0;
ee4512ed 125) return 0;

worktree.c
e8805af1 465) clear_repository_format(&format);

Commits introducting uncovered code:
Anders Waldenborg	fd2015b3 strbuf: separate callback for strbuf_expand:ing literals
Anders Waldenborg	4f732e0f pretty: allow %(trailers) options with explicit value
Brandon Richardson	cbdeab98 commit-tree: utilize parse-options api
Daniels Umanovskis	0ecb1fc7 branch: introduce --show-current display option
Elijah Newren	d76ce4f7 log,diff-tree: add --combined-all-paths option
Jeff Hostetler	b3a5d5a8 trace2:data: add subverb for rebase
Jeff Hostetler	eee73d1d trace2:data: add editor/pager child classification
Jeff Hostetler	ee4512ed trace2: create new combined trace facility
Jeff Hostetler	a15860dc trace2: t/helper/test-trace2, t0210.sh, t0211.sh, t0212.sh
Jeff King	8d8c2a5a fsck: always compute USED flags for unreachable objects
Jeff King	d55a30bb prune: lazily perform reachability traversal
Jeff King	fde67d68 prune: use bitmaps for reachability traversal
Jeff King	c409d108 pack-objects: drop unused parameter from oe_map_new_pack()
Jeff King	37c80012 fetch: avoid calling write_or_die()
Johannes Schindelin	cbd29ead built-in rebase: set ORIG_HEAD just once, before the rebase
Jonathan Tan	a97d0079 remote-curl: use post_rpc() for protocol v2 also
Martin Ågren	e8805af1 setup: fix memory leaks with `struct repository_format`
Michal Suchanek	7af01f23 worktree: fix worktree add race
Nguyễn Thái Ngọc Duy	7f64850d diff-parseopt: convert -C|--find-copies
Nguyễn Thái Ngọc Duy	84b5089e diff-parseopt: convert --stat*
Nguyễn Thái Ngọc Duy	f41179f1 parse-options: avoid magic return codes
Nguyễn Thái Ngọc Duy	202fbb33 parse-options: add one-shot mode
Nguyễn Thái Ngọc Duy	bf3ff338 parse-options: stop abusing 'callback' for lowlevel callbacks
Nguyễn Thái Ngọc Duy	f476308b diff-parseopt: convert -M|--find-renames
Nguyễn Thái Ngọc Duy	3ebbe289 parse-options: allow ll_callback with OPTION_CALLBACK
Nguyễn Thái Ngọc Duy	ced4e179 diff-parseopt: convert -B|--break-rewrites
Nguyễn Thái Ngọc Duy	af2f3680 diff-parseopt: convert --output-*
Nguyễn Thái Ngọc Duy	7d7942b7 diff-parseopt: convert --[no-]compact-summary
Nguyễn Thái Ngọc Duy	4ce7aab5 diff-parseopt: convert --dirstat and friends
Nguyễn Thái Ngọc Duy	f62470c6 parse-options: add OPT_BITOP()
Nguyễn Thái Ngọc Duy	d473e2e0 diff.c: convert -U|--unified
Ramsay Jones	9b0bd87e prune-packed: check for too many arguments
Thomas Gummerer	536ec183 entry: support CE_WT_REMOVE flag in checkout_entry
Thomas Gummerer	091e04bc checkout: introduce --{,no-}overlay option
William Hubbs	39ab4d09 config: allow giving separate author and committer idents


