pu	0eb15c0b7afaad89a10828fd22c1b5e71a7fc05a
jch	e959e06b801d996caacda98a3ac952e644e22e7c
next	b571404aecccbd67727636813e633bcd481c0f3d
master	d62dad7a7dca3f6a65162bf0e52cdf6927958e78
master@{1}	8feddda32cc50e928404788d7b9377c0b5f73f50


Uncovered code in 'pu' not in 'jch'
--------------------------------------------------------

builtin/commit.c
8e7e6c05 1668) return 1;

builtin/config.c
a12c1ff3 110) die(_("$HOME not set"));
a12c1ff3 122) given_config_source.file = git_etc_gitconfig();
6f11fd5e 489) BUG("action %d cannot get here", actions);
6f11fd5e 503) die(_("unknown config source"));
6f11fd5e 509) die(_("invalid key pattern: %s"), key);

builtin/gc.c
8e7e6c05 670) return 1;

builtin/rebase.c
e3aed7fe 1224) if (is_interactive(&options))
e3aed7fe 1225) trace2_cmd_mode("interactive");
e3aed7fe 1226) else if (exec.nr)
e3aed7fe 1227) trace2_cmd_mode("interactive-exec");
e3aed7fe 1229) trace2_cmd_mode(action_names[action]);

commit-graph.c
b1beb050 877) error(_("unsupported commit-graph version %d"),
b1beb050 879) return 1;
8e7e6c05 929) error(_("error adding pack %s"), packname.buf);
8e7e6c05 930) res = 1;
8e7e6c05 931) goto cleanup;
8e7e6c05 934) error(_("error opening index for %s"), packname.buf);
8e7e6c05 935) res = 1;
8e7e6c05 936) goto cleanup;
8e7e6c05 1009) error(_("the commit graph format cannot write %d commits"), count_distinct);
8e7e6c05 1010) res = 1;
8e7e6c05 1011) goto cleanup;
8e7e6c05 1045) error(_("too many commits to write graph"));
8e7e6c05 1046) res = 1;
8e7e6c05 1047) goto cleanup;
8e7e6c05 1055) error(_("unable to create leading directories of %s"),
8e7e6c05 1057) res = errno;
8e7e6c05 1058) goto cleanup;

config.c
8f7c7f55 2143) int repo_config_set_gently(struct repository *r,
8f7c7f55 2146) char *path = repo_git_path(r, "config");
8f7c7f55 2147) int ret = git_config_set_multivar_in_file_gently(path, key, value, NULL, 0);
8f7c7f55 2148) free(path);
8f7c7f55 2149) return ret;
8f7c7f55 2152) void repo_config_set(struct repository *r, const char *key, const char *value)
8f7c7f55 2154) if (!repo_config_set_gently(r, key, value))
8f7c7f55 2155) return;
8f7c7f55 2156) if (value)
8f7c7f55 2157) die(_("could not set '%s' to '%s'"), key, value);
8f7c7f55 2159) die(_("could not unset '%s'"), key);
8f7c7f55 2162) int repo_config_set_worktree_gently(struct repository *r,
8f7c7f55 2168) path = get_worktree_config(r);
8f7c7f55 2169) if (!path)
8f7c7f55 2170) return CONFIG_INVALID_FILE;
8f7c7f55 2171) ret = git_config_set_multivar_in_file_gently(path, key, value, NULL, 0);
8f7c7f55 2172) free(path);
8f7c7f55 2173) return ret;

git.c
01e9ead8 155) trace2_cmd_name("_query_");
01e9ead8 159) trace2_cmd_name("_query_");
01e9ead8 163) trace2_cmd_name("_query_");

http.c
ba81921a 1999) if (fflush((FILE *)result)) {
ba81921a 2003) rewind((FILE *)result);
ba81921a 2004) if (ftruncate(fileno((FILE *)result), 0) < 0) {

pager.c
6a56084b 103) pager_process->trace2_child_class = "pager";

protocol.c
6da1f1a9 37) die(_("Unrecognized protocol version"));
6da1f1a9 39) die(_("Unrecognized protocol_version"));
7ed58eb9 63) die("unknown value for %s: %s", git_test_k, git_test_v);
6da1f1a9 74) BUG("late attempt to register an allowed protocol version");

ref-filter.c
358c9418 93) keydata_aka_refname ? keydata_aka_refname : k->wt->head_ref);

remote-curl.c
6da1f1a9 344) return 0;

run-command.c
01e9ead8 239) int ec = errno;
01e9ead8 240) trace2_exec_result(exec_id, ec);
01e9ead8 241) errno = ec;
01e9ead8 997) int ret = wait_or_whine(cmd->pid, cmd->argv[0], 1);
01e9ead8 998) trace2_child_exit(cmd, ret);
01e9ead8 999) return ret;
01e9ead8 1021) int run_command_v_opt_tr2(const char **argv, int opt, const char *tr2_class)
01e9ead8 1023) return run_command_v_opt_cd_env_tr2(argv, opt, NULL, NULL, tr2_class);

t/helper/test-trace2.c
3fa3328f 24) return MyError;
3fa3328f 28) return MyError;
3fa3328f 52) die("expect <exit_code>");
3fa3328f 72) die("expect <exit_code>");
3fa3328f 92) die("expect <error_message>");
3fa3328f 142) return 0;
3fa3328f 169) static int ut_005exec(int argc, const char **argv)
3fa3328f 173) if (!argc)
3fa3328f 174) return 0;
3fa3328f 176) result = execv_git_cmd(argv);
3fa3328f 177) return result;
3fa3328f 186) die("%s", usage_error);
3fa3328f 191) die("%s", usage_error);
3fa3328f 227) static int print_usage(void)
3fa3328f 232) fprintf(stderr, "usage:\n");
3fa3328f 233) for_each_ut (k, ut_k)
3fa3328f 234) fprintf(stderr, "\t%s %s %s\n", USAGE_PREFIX, ut_k->ut_name,
3fa3328f 237) return 129;
3fa3328f 272) return print_usage();

trace2.c
01e9ead8 127) static void tr2main_signal_handler(int signo)
01e9ead8 134) us_now = getnanotime() / 1000;
01e9ead8 135) us_elapsed_absolute = tr2tls_absolute_elapsed(us_now);
01e9ead8 137) for_each_wanted_builtin (j, tgt_j)
01e9ead8 138) if (tgt_j->pfn_signal)
01e9ead8 139) tgt_j->pfn_signal(us_elapsed_absolute, signo);
01e9ead8 141) sigchain_pop(signo);
01e9ead8 142) raise(signo);
01e9ead8 143) }
01e9ead8 151) return;
01e9ead8 232) void trace2_cmd_path_fl(const char *file, int line, const char *pathname)
01e9ead8 237) if (!trace2_enabled)
01e9ead8 238) return;
01e9ead8 240) for_each_wanted_builtin (j, tgt_j)
01e9ead8 241) if (tgt_j->pfn_command_path_fl)
01e9ead8 242) tgt_j->pfn_command_path_fl(file, line, pathname);
01e9ead8 271) for_each_wanted_builtin (j, tgt_j)
01e9ead8 272) if (tgt_j->pfn_command_mode_fl)
01e9ead8 273) tgt_j->pfn_command_mode_fl(file, line, mode);
01e9ead8 285) for_each_wanted_builtin (j, tgt_j)
01e9ead8 286) if (tgt_j->pfn_alias_fl)
01e9ead8 287) tgt_j->pfn_alias_fl(file, line, alias, argv);
01e9ead8 304) tr2_cfg_set_fl(file, line, key, value);
01e9ead8 348) us_elapsed_child = 0;
01e9ead8 371) us_now = getnanotime() / 1000;
01e9ead8 372) us_elapsed_absolute = tr2tls_absolute_elapsed(us_now);
01e9ead8 374) exec_id = tr2tls_locked_increment(&tr2_next_exec_id);
01e9ead8 376) for_each_wanted_builtin (j, tgt_j)
01e9ead8 377) if (tgt_j->pfn_exec_fl)
01e9ead8 378) tgt_j->pfn_exec_fl(file, line, us_elapsed_absolute,
01e9ead8 381) return exec_id;
01e9ead8 384) void trace2_exec_result_fl(const char *file, int line, int exec_id, int code)
01e9ead8 391) if (!trace2_enabled)
01e9ead8 392) return;
01e9ead8 394) us_now = getnanotime() / 1000;
01e9ead8 395) us_elapsed_absolute = tr2tls_absolute_elapsed(us_now);
01e9ead8 397) for_each_wanted_builtin (j, tgt_j)
01e9ead8 398) if (tgt_j->pfn_exec_result_fl)
01e9ead8 399) tgt_j->pfn_exec_result_fl(
01e9ead8 403) void trace2_thread_start_fl(const char *file, int line, const char *thread_name)
01e9ead8 410) if (!trace2_enabled)
01e9ead8 411) return;
01e9ead8 413) if (tr2tls_is_main_thread()) {
01e9ead8 423) trace2_region_enter_printf_fl(file, line, NULL, NULL, NULL,
01e9ead8 426) return;
01e9ead8 429) us_now = getnanotime() / 1000;
01e9ead8 430) us_elapsed_absolute = tr2tls_absolute_elapsed(us_now);
01e9ead8 432) tr2tls_create_self(thread_name);
01e9ead8 434) for_each_wanted_builtin (j, tgt_j)
01e9ead8 435) if (tgt_j->pfn_thread_start_fl)
01e9ead8 436) tgt_j->pfn_thread_start_fl(file, line,
01e9ead8 440) void trace2_thread_exit_fl(const char *file, int line)
01e9ead8 448) if (!trace2_enabled)
01e9ead8 449) return;
01e9ead8 451) if (tr2tls_is_main_thread()) {
01e9ead8 462) trace2_region_leave_printf_fl(file, line, NULL, NULL, NULL,
01e9ead8 464) return;
01e9ead8 467) us_now = getnanotime() / 1000;
01e9ead8 468) us_elapsed_absolute = tr2tls_absolute_elapsed(us_now);
01e9ead8 475) tr2tls_pop_unwind_self();
01e9ead8 476) us_elapsed_thread = tr2tls_region_elasped_self(us_now);
01e9ead8 478) for_each_wanted_builtin (j, tgt_j)
01e9ead8 479) if (tgt_j->pfn_thread_exit_fl)
01e9ead8 480) tgt_j->pfn_thread_exit_fl(file, line,
01e9ead8 484) tr2tls_unset_self();
01e9ead8 494) return;
01e9ead8 509) if (repo->trace2_repo_id)
01e9ead8 510) return;
01e9ead8 512) repo->trace2_repo_id = tr2tls_locked_increment(&tr2_next_repo_id);
01e9ead8 514) for_each_wanted_builtin (j, tgt_j)
01e9ead8 515) if (tgt_j->pfn_repo_fl)
01e9ead8 516) tgt_j->pfn_repo_fl(file, line, repo);
01e9ead8 532) us_now = getnanotime() / 1000;
01e9ead8 533) us_elapsed_absolute = tr2tls_absolute_elapsed(us_now);
01e9ead8 542) for_each_wanted_builtin (j, tgt_j)
01e9ead8 543) if (tgt_j->pfn_region_enter_printf_va_fl)
01e9ead8 544) tgt_j->pfn_region_enter_printf_va_fl(
01e9ead8 548) tr2tls_push_self(us_now);
01e9ead8 599) us_now = getnanotime() / 1000;
01e9ead8 600) us_elapsed_absolute = tr2tls_absolute_elapsed(us_now);
01e9ead8 608) us_elapsed_region = tr2tls_region_elasped_self(us_now);
01e9ead8 610) tr2tls_pop_self();
01e9ead8 616) for_each_wanted_builtin (j, tgt_j)
01e9ead8 617) if (tgt_j->pfn_region_leave_printf_va_fl)
01e9ead8 618) tgt_j->pfn_region_leave_printf_va_fl(
01e9ead8 669) return;
01e9ead8 691) strbuf_addf(&buf_string, "%" PRIdMAX, value);
01e9ead8 692) trace2_data_string_fl(file, line, category, repo, key, buf_string.buf);
01e9ead8 693) strbuf_release(&buf_string);
01e9ead8 696) void trace2_data_json_fl(const char *file, int line, const char *category,
01e9ead8 706) if (!trace2_enabled)
01e9ead8 707) return;
01e9ead8 709) us_now = getnanotime() / 1000;
01e9ead8 710) us_elapsed_absolute = tr2tls_absolute_elapsed(us_now);
01e9ead8 711) us_elapsed_region = tr2tls_region_elasped_self(us_now);
01e9ead8 713) for_each_wanted_builtin (j, tgt_j)
01e9ead8 714) if (tgt_j->pfn_data_fl)
01e9ead8 715) tgt_j->pfn_data_json_fl(file, line, us_elapsed_absolute,
01e9ead8 720) void trace2_printf_va_fl(const char *file, int line, const char *fmt,
01e9ead8 728) if (!trace2_enabled)
01e9ead8 729) return;
01e9ead8 731) us_now = getnanotime() / 1000;
01e9ead8 732) us_elapsed_absolute = tr2tls_absolute_elapsed(us_now);
01e9ead8 738) for_each_wanted_builtin (j, tgt_j)
01e9ead8 739) if (tgt_j->pfn_printf_va_fl)
01e9ead8 740) tgt_j->pfn_printf_va_fl(file, line, us_elapsed_absolute,
01e9ead8 744) void trace2_printf_fl(const char *file, int line, const char *fmt, ...)
01e9ead8 748) va_start(ap, fmt);
01e9ead8 749) trace2_printf_va_fl(file, line, fmt, ap);
01e9ead8 750) va_end(ap);
01e9ead8 751) }

trace2/tr2_cfg.c
01e9ead8 21) return tr2_cfg_count_patterns;
01e9ead8 33) strbuf_setlen(buf, buf->len - 1);
01e9ead8 83) void tr2_cfg_set_fl(const char *file, int line, const char *key,
01e9ead8 86) struct tr2_cfg_data data = { file, line };
01e9ead8 88) if (tr2_cfg_load_patterns() > 0)
01e9ead8 89) tr2_cfg_cb(key, value, &data);
01e9ead8 90) }

trace2/tr2_dst.c
01e9ead8 15) static int tr2_dst_want_warning(void)
01e9ead8 19) if (tr2env_dst_debug == -1) {
01e9ead8 20) const char *env_value = getenv(TR2_ENVVAR_DST_DEBUG);
01e9ead8 21) if (!env_value || !*env_value)
01e9ead8 22) tr2env_dst_debug = 0;
01e9ead8 24) tr2env_dst_debug = atoi(env_value) > 0;
01e9ead8 27) return tr2env_dst_debug;
01e9ead8 43) if (tr2_dst_want_warning())
01e9ead8 44) warning("trace2: could not open '%s' for '%s' tracing: %s",
01e9ead8 45) tgt_value, dst->env_var_name, strerror(errno));
01e9ead8 47) tr2_dst_trace_disable(dst);
01e9ead8 48) return 0;
01e9ead8 62) static int tr2_dst_try_unix_domain_socket(struct tr2_dst *dst,
01e9ead8 67) const char *path = tgt_value + PREFIX_AF_UNIX_LEN;
01e9ead8 68) int path_len = strlen(path);
01e9ead8 70) if (!is_absolute_path(path) || path_len >= sizeof(sa.sun_path)) {
01e9ead8 71) if (tr2_dst_want_warning())
01e9ead8 72) warning("trace2: invalid AF_UNIX path '%s' for '%s' tracing",
01e9ead8 75) tr2_dst_trace_disable(dst);
01e9ead8 76) return 0;
01e9ead8 79) sa.sun_family = AF_UNIX;
01e9ead8 80) strlcpy(sa.sun_path, path, sizeof(sa.sun_path));
01e9ead8 81) if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1 ||
01e9ead8 82)     connect(fd, (struct sockaddr *)&sa, sizeof(sa)) == -1) {
01e9ead8 83) if (tr2_dst_want_warning())
01e9ead8 84) warning("trace2: could not connect to socket '%s' for '%s' tracing: %s",
01e9ead8 85) path, dst->env_var_name, strerror(errno));
01e9ead8 87) tr2_dst_trace_disable(dst);
01e9ead8 88) return 0;
01e9ead8 91) dst->fd = fd;
01e9ead8 92) dst->need_close = 1;
01e9ead8 93) dst->initialized = 1;
01e9ead8 95) return dst->fd;
01e9ead8 99) static void tr2_dst_malformed_warning(struct tr2_dst *dst,
01e9ead8 102) struct strbuf buf = STRBUF_INIT;
01e9ead8 104) strbuf_addf(&buf, "trace2: unknown trace value for '%s': '%s'",
01e9ead8 106) strbuf_addstr(
01e9ead8 111) strbuf_addstr(
01e9ead8 117) warning("%s", buf.buf);
01e9ead8 119) strbuf_release(&buf);
01e9ead8 120) }
01e9ead8 141) dst->fd = STDERR_FILENO;
01e9ead8 142) return dst->fd;
01e9ead8 146) dst->fd = atoi(tgt_value);
01e9ead8 147) return dst->fd;
01e9ead8 154) if (!strncmp(tgt_value, PREFIX_AF_UNIX, PREFIX_AF_UNIX_LEN))
01e9ead8 155) return tr2_dst_try_unix_domain_socket(dst, tgt_value);
01e9ead8 159) tr2_dst_malformed_warning(dst, tgt_value);
01e9ead8 160) tr2_dst_trace_disable(dst);
01e9ead8 161) return 0;
01e9ead8 193) if (tr2_dst_want_warning())
01e9ead8 194) warning("unable to write trace to '%s': %s", dst->env_var_name,
01e9ead8 195) strerror(errno));
01e9ead8 196) tr2_dst_trace_disable(dst);

trace2/tr2_sid.c
01e9ead8 27) return;
01e9ead8 59) tr2_sid_compute();

trace2/tr2_tgt_event.c
01e9ead8 57) tr2env_event_nesting_wanted = want_nesting;
01e9ead8 61) tr2env_event_brief = want_brief;
01e9ead8 96)     !strcmp(event_name, "atexit")) {
01e9ead8 158) static void fn_signal(uint64_t us_elapsed_absolute, int signo)
01e9ead8 160) const char *event_name = "signal";
01e9ead8 161) struct json_writer jw = JSON_WRITER_INIT;
01e9ead8 162) double t_abs = (double)us_elapsed_absolute / 1000000.0;
01e9ead8 164) jw_object_begin(&jw, 0);
01e9ead8 165) event_fmt_prepare(event_name, __FILE__, __LINE__, NULL, &jw);
01e9ead8 166) jw_object_double(&jw, "t_abs", 6, t_abs);
01e9ead8 167) jw_object_intmax(&jw, "signo", signo);
01e9ead8 168) jw_end(&jw);
01e9ead8 170) tr2_dst_write_line(&tr2dst_event, &jw.json);
01e9ead8 171) jw_release(&jw);
01e9ead8 172) }
01e9ead8 206) if (fmt && *fmt) {
01e9ead8 207) jw_object_string(jw, field_name, fmt);
01e9ead8 208) return;
01e9ead8 235) static void fn_command_path_fl(const char *file, int line, const char *pathname)
01e9ead8 237) const char *event_name = "cmd_path";
01e9ead8 238) struct json_writer jw = JSON_WRITER_INIT;
01e9ead8 240) jw_object_begin(&jw, 0);
01e9ead8 241) event_fmt_prepare(event_name, file, line, NULL, &jw);
01e9ead8 242) jw_object_string(&jw, "path", pathname);
01e9ead8 243) jw_end(&jw);
01e9ead8 245) tr2_dst_write_line(&tr2dst_event, &jw.json);
01e9ead8 246) jw_release(&jw);
01e9ead8 247) }
01e9ead8 267) static void fn_command_mode_fl(const char *file, int line, const char *mode)
01e9ead8 269) const char *event_name = "cmd_mode";
01e9ead8 270) struct json_writer jw = JSON_WRITER_INIT;
01e9ead8 272) jw_object_begin(&jw, 0);
01e9ead8 273) event_fmt_prepare(event_name, file, line, NULL, &jw);
01e9ead8 274) jw_object_string(&jw, "name", mode);
01e9ead8 275) jw_end(&jw);
01e9ead8 277) tr2_dst_write_line(&tr2dst_event, &jw.json);
01e9ead8 278) jw_release(&jw);
01e9ead8 279) }
01e9ead8 281) static void fn_alias_fl(const char *file, int line, const char *alias,
01e9ead8 284) const char *event_name = "alias";
01e9ead8 285) struct json_writer jw = JSON_WRITER_INIT;
01e9ead8 287) jw_object_begin(&jw, 0);
01e9ead8 288) event_fmt_prepare(event_name, file, line, NULL, &jw);
01e9ead8 289) jw_object_string(&jw, "alias", alias);
01e9ead8 290) jw_object_inline_begin_array(&jw, "argv");
01e9ead8 291) jw_array_argv(&jw, argv);
01e9ead8 292) jw_end(&jw);
01e9ead8 293) jw_end(&jw);
01e9ead8 295) tr2_dst_write_line(&tr2dst_event, &jw.json);
01e9ead8 296) jw_release(&jw);
01e9ead8 297) }
01e9ead8 310) jw_object_string(&jw, "child_class", "hook");
01e9ead8 311) jw_object_string(&jw, "hook_name", cmd->trace2_hook_name);
01e9ead8 318) jw_object_string(&jw, "cd", cmd->dir);
01e9ead8 322) jw_array_string(&jw, "git");
01e9ead8 352) static void fn_thread_start_fl(const char *file, int line,
01e9ead8 355) const char *event_name = "thread_start";
01e9ead8 356) struct json_writer jw = JSON_WRITER_INIT;
01e9ead8 358) jw_object_begin(&jw, 0);
01e9ead8 359) event_fmt_prepare(event_name, file, line, NULL, &jw);
01e9ead8 360) jw_end(&jw);
01e9ead8 362) tr2_dst_write_line(&tr2dst_event, &jw.json);
01e9ead8 363) jw_release(&jw);
01e9ead8 364) }
01e9ead8 366) static void fn_thread_exit_fl(const char *file, int line,
01e9ead8 370) const char *event_name = "thread_exit";
01e9ead8 371) struct json_writer jw = JSON_WRITER_INIT;
01e9ead8 372) double t_rel = (double)us_elapsed_thread / 1000000.0;
01e9ead8 374) jw_object_begin(&jw, 0);
01e9ead8 375) event_fmt_prepare(event_name, file, line, NULL, &jw);
01e9ead8 376) jw_object_double(&jw, "t_rel", 6, t_rel);
01e9ead8 377) jw_end(&jw);
01e9ead8 379) tr2_dst_write_line(&tr2dst_event, &jw.json);
01e9ead8 380) jw_release(&jw);
01e9ead8 381) }
01e9ead8 383) static void fn_exec_fl(const char *file, int line, uint64_t us_elapsed_absolute,
01e9ead8 386) const char *event_name = "exec";
01e9ead8 387) struct json_writer jw = JSON_WRITER_INIT;
01e9ead8 389) jw_object_begin(&jw, 0);
01e9ead8 390) event_fmt_prepare(event_name, file, line, NULL, &jw);
01e9ead8 391) jw_object_intmax(&jw, "exec_id", exec_id);
01e9ead8 392) if (exe)
01e9ead8 393) jw_object_string(&jw, "exe", exe);
01e9ead8 394) jw_object_inline_begin_array(&jw, "argv");
01e9ead8 395) jw_array_argv(&jw, argv);
01e9ead8 396) jw_end(&jw);
01e9ead8 397) jw_end(&jw);
01e9ead8 399) tr2_dst_write_line(&tr2dst_event, &jw.json);
01e9ead8 400) jw_release(&jw);
01e9ead8 401) }
01e9ead8 403) static void fn_exec_result_fl(const char *file, int line,
01e9ead8 407) const char *event_name = "exec_result";
01e9ead8 408) struct json_writer jw = JSON_WRITER_INIT;
01e9ead8 410) jw_object_begin(&jw, 0);
01e9ead8 411) event_fmt_prepare(event_name, file, line, NULL, &jw);
01e9ead8 412) jw_object_intmax(&jw, "exec_id", exec_id);
01e9ead8 413) jw_object_intmax(&jw, "code", code);
01e9ead8 414) jw_end(&jw);
01e9ead8 416) tr2_dst_write_line(&tr2dst_event, &jw.json);
01e9ead8 417) jw_release(&jw);
01e9ead8 418) }
01e9ead8 436) static void fn_repo_fl(const char *file, int line,
01e9ead8 439) const char *event_name = "def_repo";
01e9ead8 440) struct json_writer jw = JSON_WRITER_INIT;
01e9ead8 442) jw_object_begin(&jw, 0);
01e9ead8 443) event_fmt_prepare(event_name, file, line, repo, &jw);
01e9ead8 444) jw_object_string(&jw, "worktree", repo->worktree);
01e9ead8 445) jw_end(&jw);
01e9ead8 447) tr2_dst_write_line(&tr2dst_event, &jw.json);
01e9ead8 448) jw_release(&jw);
01e9ead8 449) }
01e9ead8 451) static void fn_region_enter_printf_va_fl(const char *file, int line,
01e9ead8 458) const char *event_name = "region_enter";
01e9ead8 459) struct tr2tls_thread_ctx *ctx = tr2tls_get_self();
01e9ead8 460) if (ctx->nr_open_regions <= tr2env_event_nesting_wanted) {
01e9ead8 461) struct json_writer jw = JSON_WRITER_INIT;
01e9ead8 463) jw_object_begin(&jw, 0);
01e9ead8 464) event_fmt_prepare(event_name, file, line, repo, &jw);
01e9ead8 465) jw_object_intmax(&jw, "nesting", ctx->nr_open_regions);
01e9ead8 466) if (category)
01e9ead8 467) jw_object_string(&jw, "category", category);
01e9ead8 468) if (label)
01e9ead8 469) jw_object_string(&jw, "label", label);
01e9ead8 470) maybe_add_string_va(&jw, "msg", fmt, ap);
01e9ead8 471) jw_end(&jw);
01e9ead8 473) tr2_dst_write_line(&tr2dst_event, &jw.json);
01e9ead8 474) jw_release(&jw);
01e9ead8 476) }
01e9ead8 478) static void fn_region_leave_printf_va_fl(
01e9ead8 483) const char *event_name = "region_leave";
01e9ead8 484) struct tr2tls_thread_ctx *ctx = tr2tls_get_self();
01e9ead8 485) if (ctx->nr_open_regions <= tr2env_event_nesting_wanted) {
01e9ead8 486) struct json_writer jw = JSON_WRITER_INIT;
01e9ead8 487) double t_rel = (double)us_elapsed_region / 1000000.0;
01e9ead8 489) jw_object_begin(&jw, 0);
01e9ead8 490) event_fmt_prepare(event_name, file, line, repo, &jw);
01e9ead8 491) jw_object_double(&jw, "t_rel", 6, t_rel);
01e9ead8 492) jw_object_intmax(&jw, "nesting", ctx->nr_open_regions);
01e9ead8 493) if (category)
01e9ead8 494) jw_object_string(&jw, "category", category);
01e9ead8 495) if (label)
01e9ead8 496) jw_object_string(&jw, "label", label);
01e9ead8 497) maybe_add_string_va(&jw, "msg", fmt, ap);
01e9ead8 498) jw_end(&jw);
01e9ead8 500) tr2_dst_write_line(&tr2dst_event, &jw.json);
01e9ead8 501) jw_release(&jw);
01e9ead8 503) }
01e9ead8 532) static void fn_data_json_fl(const char *file, int line,
01e9ead8 538) const char *event_name = "data_json";
01e9ead8 539) struct tr2tls_thread_ctx *ctx = tr2tls_get_self();
01e9ead8 540) if (ctx->nr_open_regions <= tr2env_event_nesting_wanted) {
01e9ead8 541) struct json_writer jw = JSON_WRITER_INIT;
01e9ead8 542) double t_abs = (double)us_elapsed_absolute / 1000000.0;
01e9ead8 543) double t_rel = (double)us_elapsed_region / 1000000.0;
01e9ead8 545) jw_object_begin(&jw, 0);
01e9ead8 546) event_fmt_prepare(event_name, file, line, repo, &jw);
01e9ead8 547) jw_object_double(&jw, "t_abs", 6, t_abs);
01e9ead8 548) jw_object_double(&jw, "t_rel", 6, t_rel);
01e9ead8 549) jw_object_intmax(&jw, "nesting", ctx->nr_open_regions);
01e9ead8 550) jw_object_string(&jw, "category", category);
01e9ead8 551) jw_object_string(&jw, "key", key);
01e9ead8 552) jw_object_sub_jw(&jw, "value", value);
01e9ead8 553) jw_end(&jw);
01e9ead8 555) tr2_dst_write_line(&tr2dst_event, &jw.json);
01e9ead8 556) jw_release(&jw);
01e9ead8 558) }

trace2/tr2_tgt_normal.c
01e9ead8 105) static void fn_signal(uint64_t us_elapsed_absolute, int signo)
01e9ead8 107) struct strbuf buf_payload = STRBUF_INIT;
01e9ead8 108) double elapsed = (double)us_elapsed_absolute / 1000000.0;
01e9ead8 110) strbuf_addf(&buf_payload, "signal elapsed:%.6f code:%d", elapsed,
01e9ead8 112) normal_io_write_fl(__FILE__, __LINE__, &buf_payload);
01e9ead8 113) strbuf_release(&buf_payload);
01e9ead8 114) }
01e9ead8 138) if (fmt && *fmt) {
01e9ead8 139) strbuf_addstr(buf, fmt);
01e9ead8 140) return;
01e9ead8 155) static void fn_command_path_fl(const char *file, int line, const char *pathname)
01e9ead8 157) struct strbuf buf_payload = STRBUF_INIT;
01e9ead8 159) strbuf_addf(&buf_payload, "cmd_path %s", pathname);
01e9ead8 160) normal_io_write_fl(file, line, &buf_payload);
01e9ead8 161) strbuf_release(&buf_payload);
01e9ead8 162) }
01e9ead8 177) static void fn_command_mode_fl(const char *file, int line, const char *mode)
01e9ead8 179) struct strbuf buf_payload = STRBUF_INIT;
01e9ead8 181) strbuf_addf(&buf_payload, "cmd_mode %s", mode);
01e9ead8 182) normal_io_write_fl(file, line, &buf_payload);
01e9ead8 183) strbuf_release(&buf_payload);
01e9ead8 184) }
01e9ead8 186) static void fn_alias_fl(const char *file, int line, const char *alias,
01e9ead8 189) struct strbuf buf_payload = STRBUF_INIT;
01e9ead8 191) strbuf_addf(&buf_payload, "alias %s ->", alias);
01e9ead8 192) sq_quote_argv_pretty(&buf_payload, argv);
01e9ead8 193) normal_io_write_fl(file, line, &buf_payload);
01e9ead8 194) strbuf_release(&buf_payload);
01e9ead8 195) }
01e9ead8 197) static void fn_child_start_fl(const char *file, int line,
01e9ead8 201) struct strbuf buf_payload = STRBUF_INIT;
01e9ead8 203) strbuf_addf(&buf_payload, "child_start[%d] ", cmd->trace2_child_id);
01e9ead8 205) if (cmd->dir) {
01e9ead8 206) strbuf_addstr(&buf_payload, " cd");
01e9ead8 207) sq_quote_buf_pretty(&buf_payload, cmd->dir);
01e9ead8 208) strbuf_addstr(&buf_payload, "; ");
01e9ead8 216) if (cmd->git_cmd)
01e9ead8 217) strbuf_addstr(&buf_payload, "git");
01e9ead8 218) sq_quote_argv_pretty(&buf_payload, cmd->argv);
01e9ead8 220) normal_io_write_fl(file, line, &buf_payload);
01e9ead8 221) strbuf_release(&buf_payload);
01e9ead8 222) }
01e9ead8 224) static void fn_child_exit_fl(const char *file, int line,
01e9ead8 228) struct strbuf buf_payload = STRBUF_INIT;
01e9ead8 229) double elapsed = (double)us_elapsed_child / 1000000.0;
01e9ead8 231) strbuf_addf(&buf_payload, "child_exit[%d] pid:%d code:%d elapsed:%.6f",
01e9ead8 233) normal_io_write_fl(file, line, &buf_payload);
01e9ead8 234) strbuf_release(&buf_payload);
01e9ead8 235) }
01e9ead8 237) static void fn_exec_fl(const char *file, int line, uint64_t us_elapsed_absolute,
01e9ead8 240) struct strbuf buf_payload = STRBUF_INIT;
01e9ead8 242) strbuf_addf(&buf_payload, "exec[%d] ", exec_id);
01e9ead8 243) if (exe)
01e9ead8 244) strbuf_addstr(&buf_payload, exe);
01e9ead8 245) sq_quote_argv_pretty(&buf_payload, argv);
01e9ead8 246) normal_io_write_fl(file, line, &buf_payload);
01e9ead8 247) strbuf_release(&buf_payload);
01e9ead8 248) }
01e9ead8 250) static void fn_exec_result_fl(const char *file, int line,
01e9ead8 254) struct strbuf buf_payload = STRBUF_INIT;
01e9ead8 256) strbuf_addf(&buf_payload, "exec_result[%d] code:%d", exec_id, code);
01e9ead8 257) if (code > 0)
01e9ead8 258) strbuf_addf(&buf_payload, " err:%s", strerror(code));
01e9ead8 259) normal_io_write_fl(file, line, &buf_payload);
01e9ead8 260) strbuf_release(&buf_payload);
01e9ead8 261) }
01e9ead8 263) static void fn_param_fl(const char *file, int line, const char *param,
01e9ead8 266) struct strbuf buf_payload = STRBUF_INIT;
01e9ead8 268) strbuf_addf(&buf_payload, "def_param %s=%s", param, value);
01e9ead8 269) normal_io_write_fl(file, line, &buf_payload);
01e9ead8 270) strbuf_release(&buf_payload);
01e9ead8 271) }
01e9ead8 273) static void fn_repo_fl(const char *file, int line,
01e9ead8 276) struct strbuf buf_payload = STRBUF_INIT;
01e9ead8 278) strbuf_addstr(&buf_payload, "worktree ");
01e9ead8 279) sq_quote_buf_pretty(&buf_payload, repo->worktree);
01e9ead8 280) normal_io_write_fl(file, line, &buf_payload);
01e9ead8 281) strbuf_release(&buf_payload);
01e9ead8 282) }
01e9ead8 284) static void fn_printf_va_fl(const char *file, int line,
01e9ead8 288) struct strbuf buf_payload = STRBUF_INIT;
01e9ead8 290) maybe_append_string_va(&buf_payload, fmt, ap);
01e9ead8 291) normal_io_write_fl(file, line, &buf_payload);
01e9ead8 292) strbuf_release(&buf_payload);
01e9ead8 293) }

trace2/tr2_tgt_perf.c
01e9ead8 102) strbuf_addf(buf, "r%d ", repo->trace2_repo_id);
01e9ead8 125) strbuf_addbuf(buf, &dots);
01e9ead8 126) len_indent -= dots.len;
01e9ead8 187) static void fn_signal(uint64_t us_elapsed_absolute, int signo)
01e9ead8 189) const char *event_name = "signal";
01e9ead8 190) struct strbuf buf_payload = STRBUF_INIT;
01e9ead8 192) strbuf_addf(&buf_payload, "signo:%d", signo);
01e9ead8 194) perf_io_write_fl(__FILE__, __LINE__, event_name, NULL,
01e9ead8 196) strbuf_release(&buf_payload);
01e9ead8 197) }
01e9ead8 223) if (fmt && *fmt) {
01e9ead8 224) strbuf_addstr(buf, fmt);
01e9ead8 225) return;
01e9ead8 242) static void fn_command_path_fl(const char *file, int line, const char *pathname)
01e9ead8 244) const char *event_name = "cmd_path";
01e9ead8 245) struct strbuf buf_payload = STRBUF_INIT;
01e9ead8 247) strbuf_addstr(&buf_payload, pathname);
01e9ead8 249) perf_io_write_fl(file, line, event_name, NULL, NULL, NULL, NULL,
01e9ead8 251) strbuf_release(&buf_payload);
01e9ead8 252) }
01e9ead8 270) static void fn_command_mode_fl(const char *file, int line, const char *mode)
01e9ead8 272) const char *event_name = "cmd_mode";
01e9ead8 273) struct strbuf buf_payload = STRBUF_INIT;
01e9ead8 275) strbuf_addstr(&buf_payload, mode);
01e9ead8 277) perf_io_write_fl(file, line, event_name, NULL, NULL, NULL, NULL,
01e9ead8 279) strbuf_release(&buf_payload);
01e9ead8 280) }
01e9ead8 282) static void fn_alias_fl(const char *file, int line, const char *alias,
01e9ead8 285) const char *event_name = "alias";
01e9ead8 286) struct strbuf buf_payload = STRBUF_INIT;
01e9ead8 288) strbuf_addf(&buf_payload, "alias:%s argv:", alias);
01e9ead8 289) sq_quote_argv_pretty(&buf_payload, argv);
01e9ead8 291) perf_io_write_fl(file, line, event_name, NULL, NULL, NULL, NULL,
01e9ead8 293) strbuf_release(&buf_payload);
01e9ead8 294) }
01e9ead8 304) strbuf_addf(&buf_payload, "[ch%d] class:hook hook:%s",
01e9ead8 314) strbuf_addstr(&buf_payload, " cd:");
01e9ead8 315) sq_quote_buf_pretty(&buf_payload, cmd->dir);
01e9ead8 320) strbuf_addstr(&buf_payload, " git");
01e9ead8 342) static void fn_thread_start_fl(const char *file, int line,
01e9ead8 345) const char *event_name = "thread_start";
01e9ead8 346) struct strbuf buf_payload = STRBUF_INIT;
01e9ead8 348) perf_io_write_fl(file, line, event_name, NULL, &us_elapsed_absolute,
01e9ead8 350) strbuf_release(&buf_payload);
01e9ead8 351) }
01e9ead8 353) static void fn_thread_exit_fl(const char *file, int line,
01e9ead8 357) const char *event_name = "thread_exit";
01e9ead8 358) struct strbuf buf_payload = STRBUF_INIT;
01e9ead8 360) perf_io_write_fl(file, line, event_name, NULL, &us_elapsed_absolute,
01e9ead8 362) strbuf_release(&buf_payload);
01e9ead8 363) }
01e9ead8 365) static void fn_exec_fl(const char *file, int line, uint64_t us_elapsed_absolute,
01e9ead8 368) const char *event_name = "exec";
01e9ead8 369) struct strbuf buf_payload = STRBUF_INIT;
01e9ead8 371) strbuf_addf(&buf_payload, "id:%d ", exec_id);
01e9ead8 372) strbuf_addstr(&buf_payload, "argv:");
01e9ead8 373) if (exe)
01e9ead8 374) strbuf_addf(&buf_payload, " %s", exe);
01e9ead8 375) sq_quote_argv_pretty(&buf_payload, argv);
01e9ead8 377) perf_io_write_fl(file, line, event_name, NULL, &us_elapsed_absolute,
01e9ead8 379) strbuf_release(&buf_payload);
01e9ead8 380) }
01e9ead8 382) static void fn_exec_result_fl(const char *file, int line,
01e9ead8 386) const char *event_name = "exec_result";
01e9ead8 387) struct strbuf buf_payload = STRBUF_INIT;
01e9ead8 389) strbuf_addf(&buf_payload, "id:%d code:%d", exec_id, code);
01e9ead8 390) if (code > 0)
01e9ead8 391) strbuf_addf(&buf_payload, " err:%s", strerror(code));
01e9ead8 393) perf_io_write_fl(file, line, event_name, NULL, &us_elapsed_absolute,
01e9ead8 395) strbuf_release(&buf_payload);
01e9ead8 396) }
01e9ead8 398) static void fn_param_fl(const char *file, int line, const char *param,
01e9ead8 401) const char *event_name = "def_param";
01e9ead8 402) struct strbuf buf_payload = STRBUF_INIT;
01e9ead8 404) strbuf_addf(&buf_payload, "%s:%s", param, value);
01e9ead8 406) perf_io_write_fl(file, line, event_name, NULL, NULL, NULL, NULL,
01e9ead8 408) strbuf_release(&buf_payload);
01e9ead8 409) }
01e9ead8 411) static void fn_repo_fl(const char *file, int line,
01e9ead8 414) const char *event_name = "def_repo";
01e9ead8 415) struct strbuf buf_payload = STRBUF_INIT;
01e9ead8 417) strbuf_addstr(&buf_payload, "worktree:");
01e9ead8 418) sq_quote_buf_pretty(&buf_payload, repo->worktree);
01e9ead8 420) perf_io_write_fl(file, line, event_name, repo, NULL, NULL, NULL,
01e9ead8 422) strbuf_release(&buf_payload);
01e9ead8 423) }
01e9ead8 425) static void fn_region_enter_printf_va_fl(const char *file, int line,
01e9ead8 432) const char *event_name = "region_enter";
01e9ead8 433) struct strbuf buf_payload = STRBUF_INIT;
01e9ead8 435) if (label)
01e9ead8 436) strbuf_addf(&buf_payload, "label:%s ", label);
01e9ead8 437) maybe_append_string_va(&buf_payload, fmt, ap);
01e9ead8 439) perf_io_write_fl(file, line, event_name, repo, &us_elapsed_absolute,
01e9ead8 441) strbuf_release(&buf_payload);
01e9ead8 442) }
01e9ead8 444) static void fn_region_leave_printf_va_fl(
01e9ead8 449) const char *event_name = "region_leave";
01e9ead8 450) struct strbuf buf_payload = STRBUF_INIT;
01e9ead8 452) if (label)
01e9ead8 453) strbuf_addf(&buf_payload, "label:%s ", label);
01e9ead8 454) maybe_append_string_va(&buf_payload, fmt, ap);
01e9ead8 456) perf_io_write_fl(file, line, event_name, repo, &us_elapsed_absolute,
01e9ead8 458) strbuf_release(&buf_payload);
01e9ead8 459) }
01e9ead8 461) static void fn_data_fl(const char *file, int line, uint64_t us_elapsed_absolute,
01e9ead8 466) const char *event_name = "data";
01e9ead8 467) struct strbuf buf_payload = STRBUF_INIT;
01e9ead8 469) strbuf_addf(&buf_payload, "%s:%s", key, value);
01e9ead8 471) perf_io_write_fl(file, line, event_name, repo, &us_elapsed_absolute,
01e9ead8 473) strbuf_release(&buf_payload);
01e9ead8 474) }
01e9ead8 476) static void fn_data_json_fl(const char *file, int line,
01e9ead8 482) const char *event_name = "data_json";
01e9ead8 483) struct strbuf buf_payload = STRBUF_INIT;
01e9ead8 485) strbuf_addf(&buf_payload, "%s:%s", key, value->json.buf);
01e9ead8 487) perf_io_write_fl(file, line, event_name, repo, &us_elapsed_absolute,
01e9ead8 489) strbuf_release(&buf_payload);
01e9ead8 490) }
01e9ead8 492) static void fn_printf_va_fl(const char *file, int line,
01e9ead8 496) const char *event_name = "printf";
01e9ead8 497) struct strbuf buf_payload = STRBUF_INIT;
01e9ead8 499) maybe_append_string_va(&buf_payload, fmt, ap);
01e9ead8 501) perf_io_write_fl(file, line, event_name, NULL, &us_elapsed_absolute,
01e9ead8 503) strbuf_release(&buf_payload);
01e9ead8 504) }

trace2/tr2_tls.c
01e9ead8 38) strbuf_addf(&ctx->thread_name, "th%02d:", ctx->thread_id);
01e9ead8 41) strbuf_setlen(&ctx->thread_name, TR2_MAX_THREAD_NAME);
01e9ead8 58) ctx = tr2tls_create_self("unknown");
01e9ead8 63) int tr2tls_is_main_thread(void)
01e9ead8 65) struct tr2tls_thread_ctx *ctx = pthread_getspecific(tr2tls_key);
01e9ead8 67) return ctx == tr2tls_thread_main;
01e9ead8 82) void tr2tls_push_self(uint64_t us_now)
01e9ead8 84) struct tr2tls_thread_ctx *ctx = tr2tls_get_self();
01e9ead8 86) ALLOC_GROW(ctx->array_us_start, ctx->nr_open_regions + 1, ctx->alloc);
01e9ead8 87) ctx->array_us_start[ctx->nr_open_regions++] = us_now;
01e9ead8 88) }
01e9ead8 90) void tr2tls_pop_self(void)
01e9ead8 92) struct tr2tls_thread_ctx *ctx = tr2tls_get_self();
01e9ead8 94) if (!ctx->nr_open_regions)
01e9ead8 95) BUG("no open regions in thread '%s'", ctx->thread_name.buf);
01e9ead8 97) ctx->nr_open_regions--;
01e9ead8 98) }
01e9ead8 105) tr2tls_pop_self();
01e9ead8 115) return 0;
01e9ead8 125) return 0;

wrapper.c
5efde212 70) die("Out of memory, malloc failed (tried to allocate %" PRIuMAX " bytes)",
5efde212 73) error("Out of memory, malloc failed (tried to allocate %" PRIuMAX " bytes)",

Commits introducting uncovered code:
Dan McGregor	ba81921a http: cast result to FILE *
Derrick Stolee	8e7e6c05 commit-graph: return with errors during write
Derrick Stolee	b1beb050 commit-graph: create new version flags
Jeff Hostetler	e3aed7fe trace2:data: add subverb for rebase
Jeff Hostetler	01e9ead8 trace2: create new combined trace facility
Jeff Hostetler	6a56084b trace2:data: add editor/pager child classification
Jeff Hostetler	3fa3328f trace2: t/helper/test-trace2, t0210.sh, t0211.sh, t0212.sh
Jonathan Tan	7ed58eb9 tests: define GIT_TEST_PROTOCOL_VERSION
Josh Steadmon	6da1f1a9 protocol: advertise multiple supported versions
Martin Koegler	5efde212 zlib.c: use size_t for size
Nguyễn Thái Ngọc Duy	a12c1ff3 config: factor out set_config_source_file()
Nguyễn Thái Ngọc Duy	6f11fd5e config: add --move-to
Nguyễn Thái Ngọc Duy	8f7c7f55 config.c: add repo_config_set_worktree_gently()
Nickolai Belakovski	358c9418 ref-filter: add worktreepath atom


Uncovered code in 'jch' not in 'next'
--------------------------------------------------------

blame.c
07d04b91 483)     ent->s_lno + ent->num_lines == next->s_lno &&
07d04b91 484)     ent->ignored == next->ignored) {
e7973c85 941) blame_origin_decref(e->suspect);
e7973c85 942) e->suspect = blame_origin_incref(parent);
e7973c85 943) e->s_lno += offset;
07d04b91 944) e->ignored = 1;
e7973c85 945) e->next = ignoredp;
e7973c85 946) ignoredp = e;
e7973c85 954) **dstq = reverse_blame(ignoredp, **dstq);
e7973c85 955) *dstq = &ignoredp->next;
e7973c85 1528) for (i = 0, sg = first_scapegoat(revs, commit, sb->reverse);
e7973c85 1529)      i < num_sg && sg;
e7973c85 1530)      sg = sg->next, i++) {
e7973c85 1531) struct blame_origin *porigin = sg_origin[i];
e7973c85 1533) if (!porigin)
e7973c85 1534) continue;
e7973c85 1535) pass_blame_to_parent(sb, origin, porigin, 1);
e7973c85 1536) if (!origin->suspects)
e7973c85 1537) goto finish;

builtin/blame.c
07d04b91 485) length--;
07d04b91 486) putchar('*');
e7973c85 705) return git_config_pathname(&ignore_revs_file, var, value);
07d04b91 707) mark_ignored_lines = git_config_bool(var, value);
07d04b91 708) return 0;
e7973c85 797) oidset_parse_file(&sb->ignore_list, ignore_revs_file);
e7973c85 799) if (get_oid_committish(i->string, &oid))
e7973c85 800) die(_("Can't find revision '%s' to ignore"), i->string);
e7973c85 801) oidset_insert(&sb->ignore_list, &oid);

builtin/branch.c
0ecb1fc7 452) die(_("could not resolve HEAD"));
0ecb1fc7 458) die(_("HEAD (%s) points outside of refs/heads/"), refname);

builtin/multi-pack-index.c
467ae6f9 49) die(_("--batch-size option is only for 'repack' subcommand"));
467ae6f9 58) die(_("unrecognized subcommand: %s"), argv[0]);

builtin/rebase--interactive.c
c0108d5c 24) return error_errno(_("could not read '%s'."), todo_file);
c0108d5c 31) return error_errno(_("could not write '%s'"), todo_file);
30faf278 46) return error_errno(_("could not read '%s'."), todo_file);
30faf278 50) todo_list_release(&todo_list);
30faf278 51) return error(_("unusable todo list: '%s'"), todo_file);
30faf278 59) return error_errno(_("could not write '%s'."), todo_file);
1f4d9b1b 157) BUG("unusable todo list");
acabb2aa 313) ret = rearrange_squash_in_todo_file(the_repository);
6d3f180e 316) ret = sequencer_add_exec_commands(the_repository, &commands);

builtin/remote.c
f39a9c65 1551) die(_("--save-to-push cannot be used with other options"));
f39a9c65 1575) die(_("--save-to-push can only be used when only one url is defined"));

builtin/stash.c
f6bbd781 128) die(_("'%s' is not a stash-like commit"), revision);
f6bbd781 161) free_stash_info(info);
f6bbd781 162) fprintf_ln(stderr, _("No stash entries found."));
f6bbd781 163) return -1;
f6bbd781 198) free_stash_info(info);
cdca49bc 225) return error(_("git stash clear with parameters is "
f6bbd781 241) return -1;
f6bbd781 249) return -1;
f6bbd781 265) return error(_("unable to write new index file"));
f6bbd781 377) remove_path(stash_index_path.buf);
f6bbd781 378) return -1;
f6bbd781 405) return -1;
f6bbd781 408) return error(_("cannot apply a stash in the middle of a merge"));
f6bbd781 418) strbuf_release(&out);
f6bbd781 419) return error(_("could not generate diff %s^!."),
f6bbd781 426) return error(_("conflicts in index."
f6bbd781 432) return error(_("could not save index tree"));
f6bbd781 439) return error(_("could not restore untracked files from stash"));
f6bbd781 470) return -1;
f6bbd781 475) strbuf_release(&out);
f6bbd781 480) strbuf_release(&out);
f6bbd781 481) return -1;
cdca49bc 557) return error(_("%s: Could not drop stash entry"),
e1d01876 632) printf_ln(_("The stash entry is kept in case "
b4493f26 766) free_stash_info(&info);
51809c70 767) usage_with_options(git_stash_show_usage, options);
847eb0b0 783) stash_msg = "Created via \"git stash store\".";
847eb0b0 789) if (!quiet) {
847eb0b0 790) fprintf_ln(stderr, _("Cannot update %s with %s"),
847eb0b0 793) return -1;
847eb0b0 817) if (!quiet)
847eb0b0 818) fprintf_ln(stderr, _("\"git stash store\" requires one "
847eb0b0 820) return -1;
1f5a011d 903) return -1;
1f5a011d 963) ret = -1;
1f5a011d 964) goto done;
1f5a011d 969) ret = -1;
1f5a011d 970) goto done;
1f5a011d 975) ret = -1;
1f5a011d 976) goto done;
1f5a011d 1002) ret = -1;
1f5a011d 1003) goto done;
1f5a011d 1014) ret = -1;
1f5a011d 1015) goto done;
1f5a011d 1021) ret = -1;
1f5a011d 1022) goto done;
1f5a011d 1029) ret = -1;
1f5a011d 1030) goto done;
1f5a011d 1068) ret = -1;
1f5a011d 1069) goto done;
1f5a011d 1075) ret = -1;
1f5a011d 1076) goto done;
1f5a011d 1087) ret = -1;
1f5a011d 1088) goto done;
1f5a011d 1093) ret = -1;
1f5a011d 1094) goto done;
9a95010a 1130) fprintf_ln(stderr, _("You do not have "
1f5a011d 1139) ret = 1;
1f5a011d 1140) goto done;
9a95010a 1156) if (!quiet)
9a95010a 1157) fprintf_ln(stderr, _("Cannot save the current "
1f5a011d 1159) ret = -1;
1f5a011d 1160) goto done;
9a95010a 1165) if (!quiet)
9a95010a 1166) fprintf_ln(stderr, _("Cannot save "
1f5a011d 1168) ret = -1;
1f5a011d 1169) goto done;
9a95010a 1176) if (!quiet)
9a95010a 1177) fprintf_ln(stderr, _("Cannot save the current "
1f5a011d 1179) goto done;
9a95010a 1213) if (!quiet)
9a95010a 1214) fprintf_ln(stderr, _("Cannot record "
1f5a011d 1216) ret = -1;
1f5a011d 1217) goto done;
fa38428f 1286) ret = -1;
fa38428f 1287) goto done;
fa38428f 1297) ret = -1;
9a95010a 1298) if (!quiet)
9a95010a 1299) fprintf_ln(stderr, _("Cannot initialize stash"));
fa38428f 1300) goto done;
fa38428f 1312) ret = -1;
9a95010a 1313) if (!quiet)
9a95010a 1314) fprintf_ln(stderr, _("Cannot save the current status"));
fa38428f 1315) goto done;
fa38428f 1332) ret = -1;
fa38428f 1351) ret = -1;
fa38428f 1352) goto done;
fa38428f 1361) ret = -1;
fa38428f 1362) goto done;
fa38428f 1370) ret = -1;
fa38428f 1379) ret = -1;
fa38428f 1390) ret = -1;
fa38428f 1391) goto done;
fa38428f 1400) ret = -1;
fa38428f 1401) goto done;
fa38428f 1409) ret = -1;
fa38428f 1435) ret = -1;
bec65d5b 1527) return env;
26799a20 1555) const char *path = mkpath("%s/git-legacy-stash",
26799a20 1558) if (sane_execvp(path, (char **)argv) < 0)
26799a20 1559) die_errno(_("could not exec %s"), path);
26799a20 1561) BUG("sane_execvp() returned???");
51809c70 1602) usage_msg_opt(xstrfmt(_("unknown subcommand: %s"), argv[0]),
51809c70 1630) continue;

combine-diff.c
26c64cee 89)     filename_changed(p->parent[j].status))
26c64cee 90) strbuf_release(&p->parent[j].path);
26c64cee 992) dump_quoted_path("--- ", "", "/dev/null",
26c64cee 1000) dump_quoted_path("--- ", "", "/dev/null",
26c64cee 1273) write_name_quoted(p->path, stdout,

midx.c
5bf52fbc 428) close_pack(packs->info[packs->nr].p);
5bf52fbc 429) FREE_AND_NULL(packs->info[packs->nr].p);
3c9e7185 688) BUG("object %s is in an expired pack with int-id %d",
3c9e7185 815) error(_("did not see pack-file %s to drop"),
3c9e7185 817) drop_index++;
3c9e7185 818) missing_drops++;
3c9e7185 819) i--;
3c9e7185 826) result = 1;
3c9e7185 827) goto cleanup;
3c9e7185 1079) return 0;
3c9e7185 1094) continue;
467ae6f9 1133) return 0;
19c239d4 1148) return 0;
19c239d4 1157) continue;
19c239d4 1170) continue;
19c239d4 1193) error(_("could not start pack-objects"));
19c239d4 1194) result = 1;
19c239d4 1195) goto cleanup;
19c239d4 1212) error(_("could not finish pack-objects"));
19c239d4 1213) result = 1;
19c239d4 1214) goto cleanup;

oidset.c
ef644c41 69) die_errno("Could not read '%s'", path);

packfile.c
91336887 369) strbuf_release(&buf);
91336887 370) return;

read-cache.c
ee70c128 1734) if (advice_unknown_index_extension) {
ee70c128 1735) warning(_("ignoring optional %.4s index extension"), ext);
ee70c128 1736) advise(_("This is likely due to the file having been written by a newer\n"

rebase-interactive.c
6ca89c6f 26) warning(_("unrecognized setting %s for option "
c0108d5c 102) return error(_("could not copy '%s' to '%s'."), todo_file,
6ca89c6f 164) goto leave_check;

revision.c
26c64cee 2654) die("--combined-all-names makes no sense without -c or --cc");

sequencer.c
6d3f180e 4606) int sequencer_add_exec_commands(struct repository *r,
6d3f180e 4614) return error_errno(_("could not read '%s'."), todo_file);
6d3f180e 4616) if (todo_list_parse_insn_buffer(r, todo_list.buf.buf, &todo_list)) {
6d3f180e 4621) todo_list_add_exec_commands(&todo_list, commands);
6d3f180e 4622) res = todo_list_write_to_file(r, &todo_list, todo_file, NULL, NULL, -1, 0);
0cce4a27 4623) todo_list_release(&todo_list);
6d3f180e 4625) if (res)
6d3f180e 4626) return error_errno(_("could not write '%s'."), todo_file);
6d3f180e 4627) return 0;
616d7740 4661) strbuf_addstr(buf, " -c");
87805600 4708) res = -1;
6ca89c6f 4709) goto out;
6ca89c6f 4714) goto out;
6ca89c6f 4723) fprintf(stderr, _(edit_todo_list_advice));
ce193960 4841) todo_list_release(&new_todo);
1f4d9b1b 4847) todo_list_release(&new_todo);
1f4d9b1b 4848) return error_errno(_("could not write '%s'"), todo_file);
acabb2aa 5025) int rearrange_squash_in_todo_file(struct repository *r)
acabb2aa 5027) const char *todo_file = rebase_path_todo();
acabb2aa 5028) struct todo_list todo_list = TODO_LIST_INIT;
acabb2aa 5029) int res = 0;
acabb2aa 5031) if (strbuf_read_file_or_whine(&todo_list.buf, todo_file) < 0)
acabb2aa 5032) return -1;
acabb2aa 5033) if (todo_list_parse_insn_buffer(r, todo_list.buf.buf, &todo_list) < 0) {
acabb2aa 5034) todo_list_release(&todo_list);
acabb2aa 5035) return -1;
acabb2aa 5038) res = todo_list_rearrange_squash(&todo_list);
acabb2aa 5039) if (!res)
acabb2aa 5040) res = todo_list_write_to_file(r, &todo_list, todo_file, NULL, NULL, -1, 0);
acabb2aa 5042) todo_list_release(&todo_list);
acabb2aa 5044) if (res)
acabb2aa 5045) return error_errno(_("could not write '%s'."), todo_file);
acabb2aa 5046) return 0;

strbuf.c
bfc3fe33 259) die("`pos' is too far after the end of the buffer");
bfc3fe33 264) BUG("your vsnprintf is broken (returned %d)", len);
bfc3fe33 266) return; /* nothing to do */
bfc3fe33 268) die("you want to use way too much memory");
bfc3fe33 276) BUG("your vsnprintf is broken (returns inconsistent lengths)");

worktree.c
e0c4a731 465) clear_repository_format(&format);

Commits introducting uncovered code:
Alban Gruin	6ca89c6f sequencer: refactor check_todo_list() to work on a todo_list
Alban Gruin	616d7740 sequencer: introduce todo_list_write_to_file()
Alban Gruin	ce193960 sequencer: refactor skip_unnecessary_picks() to work on a todo_list
Alban Gruin	c0108d5c rebase-interactive: rewrite edit_todo_list() to handle the initial edit
Alban Gruin	30faf278 rebase--interactive: move transform_todo_file() to rebase--interactive.c
Alban Gruin	1f4d9b1b sequencer: change complete_action() to use the refactored functions
Alban Gruin	acabb2aa sequencer: refactor rearrange_squash() to work on a todo_list
Alban Gruin	6d3f180e sequencer: refactor sequencer_add_exec_commands() to work on a todo_list
Barret Rhoden	07d04b91 blame: add a config option to mark ignored lines
Barret Rhoden	ef644c41 Move init_skiplist() outside of fsck
Barret Rhoden	e7973c85 blame: add the ability to ignore commits and their changes
Daniels Umanovskis	0ecb1fc7 branch: introduce --show-current display option
Denton Liu	f39a9c65 remote: add --save-to-push option to git remote set-url
Derrick Stolee	19c239d4 midx: implement midx_repack()
Derrick Stolee	467ae6f9 multi-pack-index: prepare 'repack' subcommand
Derrick Stolee	91336887 repack: refactor pack deletion for future use
Derrick Stolee	5bf52fbc midx: refactor permutation logic and pack sorting
Derrick Stolee	3c9e7185 multi-pack-index: implement 'expire' subcommand
Elijah Newren	26c64cee log,diff-tree: add --combined-all-names option
Joel Teichroeb	f6bbd781 stash: convert apply to builtin
Joel Teichroeb	cdca49bc stash: convert drop and clear to builtin
Joel Teichroeb	e1d01876 stash: convert pop to builtin
Johannes Schindelin	bec65d5b tests: add a special setup where stash.useBuiltin is off
Johannes Schindelin	26799a20 stash: optionally use the scripted version again
Jonathan Nieder	ee70c128 index: offer advice for unknown index extensions
Liam Beguin	0cce4a27 rebase -i -x: add exec commands via the rebase--helper
Martin Ågren	e0c4a731 setup: fix memory leaks with `struct repository_format`
Paul-Sebastian Ungureanu	bfc3fe33 strbuf.c: add `strbuf_insertf()` and `strbuf_vinsertf()`
Paul-Sebastian Ungureanu	1f5a011d stash: convert create to builtin
Paul-Sebastian Ungureanu	847eb0b0 stash: convert store to builtin
Paul-Sebastian Ungureanu	51809c70 stash: convert `stash--helper.c` into `stash.c`
Paul-Sebastian Ungureanu	b4493f26 stash: convert show to builtin
Paul-Sebastian Ungureanu	fa38428f stash: convert push to builtin
Paul-Sebastian Ungureanu	9a95010a stash: make push -q quiet
René Scharfe	87805600 sequencer: factor out strbuf_read_file_or_whine()


Uncovered code in 'next' not in 'master'
--------------------------------------------------------

builtin/checkout.c
091e04bc 303) return;
091e04bc 1276) die(_("'%s' cannot be used with switching branches"),

builtin/pull.c
a3b994b7 648) argv_array_push(&args, opt_cleanup);

diff.c
d473e2e0 4946) return error(_("%s expects a numerical value"), "--unified");

entry.c
536ec183 450) BUG("Can't remove entry to a path");

ident.c
39ab4d09 452) break;
39ab4d09 454) name = getenv("GIT_AUTHOR_NAME");
39ab4d09 455) email = getenv("GIT_AUTHOR_EMAIL");
39ab4d09 456) break;
39ab4d09 515) return config_error_nonbool(var);
39ab4d09 525) return config_error_nonbool(var);
39ab4d09 535) return config_error_nonbool(var);
39ab4d09 545) return config_error_nonbool(var);

parse-options.c
f62470c6 116) BUG("BITOP can't have unset form");
3ebbe289 183) return (*opt->ll_callback)(p, opt, p_arg, p_unset);
3ebbe289 255) rc = (*numopt->ll_callback)(p, numopt, arg, 0);
3ebbe289 432) BUG("OPTION_CALLBACK needs one callback");
3ebbe289 434) BUG("OPTION_CALLBACK can't have two callbacks");
bf3ff338 438) BUG("OPTION_LOWLEVEL_CALLBACK needs a callback");
bf3ff338 440) BUG("OPTION_LOWLEVEL_CALLBACK needs no high level callback");
202fbb33 475) BUG("Can't keep argv0 if you don't have it");
f41179f1 622) BUG("parse_short_opt() cannot return these");
f41179f1 647) BUG("parse_short_opt() cannot return these");
f41179f1 676) BUG("parse_long_opt() cannot return these");

pretty.c
4f732e0f 1075) return 0;
4f732e0f 1112) return 0;

remote-curl.c
8ee3e120 354) die("invalid server response; expected service, got flush packet");
8ee3e120 367) }

strbuf.c
fd2015b3 397) return 0;

Commits introducting uncovered code:
Anders Waldenborg	4f732e0f pretty: allow %(trailers) options with explicit value
Anders Waldenborg	fd2015b3 strbuf: separate callback for strbuf_expand:ing literals
Denton Liu	a3b994b7 merge: cleanup messages like commit
Jeff King	8ee3e120 remote-curl: refactor smart-http discovery
Nguyễn Thái Ngọc Duy	d473e2e0 diff.c: convert -U|--unified
Nguyễn Thái Ngọc Duy	f62470c6 parse-options: add OPT_BITOP()
Nguyễn Thái Ngọc Duy	3ebbe289 parse-options: allow ll_callback with OPTION_CALLBACK
Nguyễn Thái Ngọc Duy	bf3ff338 parse-options: stop abusing 'callback' for lowlevel callbacks
Nguyễn Thái Ngọc Duy	202fbb33 parse-options: add one-shot mode
Nguyễn Thái Ngọc Duy	f41179f1 parse-options: avoid magic return codes
Thomas Gummerer	091e04bc checkout: introduce --{,no-}overlay option
Thomas Gummerer	536ec183 entry: support CE_WT_REMOVE flag in checkout_entry
William Hubbs	39ab4d09 config: allow giving separate author and committer idents


Uncovered code in 'master' not in 'master@{1}'
--------------------------------------------------------

bisect.c
4f6d26b1 661) mark_edges_uninteresting(revs, NULL, 0);

builtin/bisect--helper.c
5e82c3dd 162) if (get_oid_commit(commit, &oid))
5e82c3dd 163) return error(_("'%s' is not a valid commit"), commit);
5e82c3dd 164) strbuf_addstr(&branch, commit);
5e82c3dd 172) strbuf_release(&branch);
5e82c3dd 173) argv_array_clear(&argv);
5e82c3dd 174) return error(_("could not check out original"
0f30233a 215) retval = error(_("Bad bisect_write argument: %s"), state);
0f30233a 216) goto finish;
0f30233a 220) retval = error(_("couldn't get the oid of the rev '%s'"), rev);
0f30233a 221) goto finish;
0f30233a 226) retval = -1;
0f30233a 227) goto finish;
0f30233a 232) retval = error_errno(_("couldn't open the file '%s'"), git_path_bisect_log());
0f30233a 233) goto finish;
129a6cf3 329) yesno = git_prompt(_("Are you sure [Y/n]? "), PROMPT_ECHO);
129a6cf3 330) if (starts_with(yesno, "N") || starts_with(yesno, "n"))
129a6cf3 331) retval = -1;
129a6cf3 332) goto finish;
129a6cf3 338) retval = error(_(need_bisect_start_warning),
450ebb73 389) return error(_("invalid argument %s for 'git bisect terms'.\n"
06f5608c 404) return -1;
06f5608c 407) retval = -1;
06f5608c 408) goto finish;
06f5608c 413) retval = -1;
06f5608c 452) no_checkout = 1;
06f5608c 474)  !one_of(arg, "--term-good", "--term-bad", NULL)) {
06f5608c 475) return error(_("unrecognized option: '%s'"), arg);
06f5608c 510) if (get_oid("HEAD", &head_oid))
06f5608c 511) return error(_("bad HEAD - I need a HEAD"));
06f5608c 526) retval = error(_("checking out '%s' failed."
06f5608c 547) return error(_("won't bisect on cg-seek'ed tree"));
06f5608c 550) return error(_("bad HEAD - strange symbolic ref"));
06f5608c 558) return -1;
06f5608c 576) retval = -1;
06f5608c 577) goto finish;
06f5608c 588) retval = -1;
06f5608c 589) goto finish;
06f5608c 600) retval = -1;
5e82c3dd 677) return error(_("--bisect-reset requires either no argument or a commit"));
0f30233a 681) return error(_("--bisect-write requires either 4 or 5 arguments"));
4fbdbd5b 687) return error(_("--check-and-set-terms requires 3 arguments"));
129a6cf3 693) return error(_("--bisect-next-check requires 2 or 3 arguments"));

builtin/blame.c
acdd3776 930) blame_date_width = sizeof("Thu Oct 19 16:00");
acdd3776 931) break;

builtin/diff-tree.c
e1ff0a32 169) repo_read_index(the_repository);

builtin/pack-objects.c
33de80b1 2225) const uint32_t tail = (idx + window - count) % window;

builtin/pack-redundant.c
33de80b1 169) const int cmp = oidcmp(l->oid, oid);
33de80b1 267) const int cmp = hashcmp(p1_base + p1_off, p2_base + p2_off);

builtin/rebase.c
21853626 259) write_file(state_dir_path("verbose", opts), "%s", "");
21853626 261) write_file(state_dir_path("strategy", opts), "%s",
21853626 264) write_file(state_dir_path("strategy_opts", opts), "%s",
21853626 271) write_file(state_dir_path("gpg_sign_opt", opts), "%s",
21853626 274) write_file(state_dir_path("strategy", opts), "--signoff");
c5233708 394) BUG("Not a fully qualified branch: '%s'", switch_to_branch);
c5233708 397) ret = -1;
c5233708 398) goto leave_reset_head;
c5233708 402) ret = error(_("could not determine HEAD revision"));
c5233708 403) goto leave_reset_head;
c5233708 424) ret = error(_("could not read index"));
c5233708 425) goto leave_reset_head;
c5233708 429) ret = error(_("failed to find tree of %s"),
c5233708 431) goto leave_reset_head;
c5233708 435) ret = error(_("failed to find tree of %s"), oid_to_hex(oid));
c5233708 436) goto leave_reset_head;
c5233708 448) ret = error(_("could not write index"));
c5233708 449) goto leave_reset_head;
c5233708 467) } else if (old_orig)
c5233708 468) delete_ref(NULL, "ORIG_HEAD", old_orig, 0);
21853626 507) BUG("move_to_original_branch without onto");
21853626 543) argv_array_push(&am.args, opts->gpg_sign_opt);
21853626 575) status = error_errno(_("could not open '%s' for writing"),
21853626 577) free(rebased_patches);
21853626 578) argv_array_clear(&am.args);
21853626 579) return status;
21853626 588) argv_array_split(&format_patch.args,
21853626 589)  opts->git_format_patch_opt.buf);
21853626 597) unlink(rebased_patches);
21853626 598) free(rebased_patches);
21853626 599) argv_array_clear(&am.args);
21853626 601) reset_head(&opts->orig_head, "checkout", opts->head_name, 0,
21853626 603) error(_("\ngit encountered an error while preparing the "
21853626 610) strbuf_release(&revisions);
21853626 611) return status;
21853626 617) status = error_errno(_("could not open '%s' for reading"),
21853626 619) free(rebased_patches);
21853626 620) argv_array_clear(&am.args);
21853626 621) return status;

date.c
acdd3776 113) die("Timestamp too large for this system: %"PRItime, time);
acdd3776 236) hide.date = 1;
acdd3776 917) return DATE_HUMAN;
2fd7c229 934) if (isatty(1) || pager_in_use())
2fd7c229 935) format = p;
2fd7c229 937) format = "default";

http-walker.c
514c5fdd 550) loose_object_path(the_repository, &buf, &req->oid);

list-objects.c
4f6d26b1 241) continue;
4f6d26b1 250) parent->object.flags |= SHOWN;
4f6d26b1 251) show_edge(parent);
4f6d26b1 272) tree->object.flags |= UNINTERESTING;
4f6d26b1 287) commit->object.flags |= SHOWN;
4f6d26b1 288) show_edge(commit);

merge-recursive.c
0d6caa2d 433) for (i = 0; i < istate->cache_nr; i++) {
0d6caa2d 434) const struct cache_entry *ce = istate->cache[i];
0d6caa2d 443) istate->cache_tree = cache_tree();
0d6caa2d 733) ce = index_file_exists(o->repo->index, path, strlen(path),
0d6caa2d 3193) remove_file_from_index(o->repo->index, path);

object.c
01f8d594 278) error(_("hash mismatch %s"), oid_to_hex(repl));

repository.c
3a95f31d 272) BUG("the repo hasn't been setup");

revision.c
d5d2e935 169) return;
d5d2e935 172) return;
d5d2e935 195) break;
f1f5de44 218) continue;

sequencer.c
899b49c4 2395) opts->quiet = 1;
e1ff0a32 3991) res = error_dirty_index(r, opts);

sha1-file.c
514c5fdd 1291) status = error(_("unable to parse %s header"), oid_to_hex(oid));
2c319886 1595) return error_errno(_("unable to write file %s"), filename);
76011357 1626) fsync_or_die(fd, "loose object file");
76011357 1628) die_errno(_("error when closing loose object file"));
76011357 1719) die(_("unable to write loose object file"));
2c319886 1818) return error(_("cannot read object for %s"), oid_to_hex(oid));
00a7760e 2297) the_hash_algo->final_fn(real_oid.hash, &c);
00a7760e 2298) if (!oideq(expected_oid, &real_oid)) {
01f8d594 2299) error(_("hash mismatch for %s (expected %s)"), path,

sha1-name.c
d1dd94b3 926) return MISSING_OBJECT;

t/helper/test-date.c
ba285a71 95) static void getnanos(const char **argv)
4419de91 97) double seconds = getnanotime() / 1.0e9;
4419de91 99) if (*argv)
4419de91 100) seconds -= strtod(*argv, NULL);
4419de91 101) printf("%lf\n", seconds);
4419de91 102) }
ba285a71 133) getnanos(argv+1);

t/helper/test-path-utils.c
b819f1d2 180) static int cmp_by_st_size(const void *a, const void *b)
b819f1d2 182) intptr_t x = (intptr_t)((struct string_list_item *)a)->util;
b819f1d2 183) intptr_t y = (intptr_t)((struct string_list_item *)b)->util;
b819f1d2 185) return x > y ? -1 : (x < y ? +1 : 0);
5868bd86 308) res = error_errno("Cannot stat '%s'", argv[i]);
af9912ef 314) if (argc == 4 && !strcmp(argv[1], "skip-n-bytes")) {
af9912ef 315) int fd = open(argv[2], O_RDONLY), offset = atoi(argv[3]);
af9912ef 318) if (fd < 0)
af9912ef 319) die_errno("could not open '%s'", argv[2]);
af9912ef 320) if (lseek(fd, offset, SEEK_SET) < 0)
af9912ef 321) die_errno("could not skip %d bytes", offset);
af9912ef 323) ssize_t count = read(fd, buffer, sizeof(buffer));
af9912ef 324) if (count < 0)
af9912ef 325) die_errno("could not read '%s'", argv[2]);
af9912ef 326) if (!count)
af9912ef 327) break;
af9912ef 328) if (write(1, buffer, count) < 0)
af9912ef 329) die_errno("could not write to stdout");
af9912ef 330) }
af9912ef 331) close(fd);
af9912ef 332) return 0;
b819f1d2 335) if (argc > 5 && !strcmp(argv[1], "slice-tests")) {
b819f1d2 336) int res = 0;
b819f1d2 338) struct string_list list = STRING_LIST_INIT_NODUP;
b819f1d2 341) offset = strtol(argv[2], NULL, 10);
b819f1d2 342) stride = strtol(argv[3], NULL, 10);
b819f1d2 343) if (stride < 1)
b819f1d2 344) stride = 1;
b819f1d2 345) for (i = 4; i < argc; i++)
b819f1d2 346) if (stat(argv[i], &st))
b819f1d2 347) res = error_errno("Cannot stat '%s'", argv[i]);
b819f1d2 349) string_list_append(&list, argv[i])->util =
b819f1d2 350) (void *)(intptr_t)st.st_size;
b819f1d2 351) QSORT(list.items, list.nr, cmp_by_st_size);
b819f1d2 352) for (i = offset; i < list.nr; i+= stride)
b819f1d2 353) printf("%s\n", list.items[i].string);
b819f1d2 355) return !!res;

t/helper/test-xml-encode.c
22231908 9) int cmd__xml_encode(int argc, const char **argv)
22231908 11) unsigned char buf[1024], tmp[4], *tmp2 = NULL;
22231908 12) ssize_t cur = 0, len = 1, remaining = 0;
22231908 16) if (++cur == len) {
22231908 17) len = xread(0, buf, sizeof(buf));
22231908 18) if (!len)
22231908 19) return 0;
22231908 20) if (len < 0)
22231908 21) die_errno("Could not read <stdin>");
22231908 22) cur = 0;
22231908 24) ch = buf[cur];
22231908 26) if (tmp2) {
22231908 27) if ((ch & 0xc0) != 0x80) {
22231908 28) fputs(utf8_replace_character, stdout);
22231908 29) tmp2 = NULL;
22231908 30) cur--;
22231908 31) continue;
22231908 33) *tmp2 = ch;
22231908 34) tmp2++;
22231908 35) if (--remaining == 0) {
22231908 36) fwrite(tmp, tmp2 - tmp, 1, stdout);
22231908 37) tmp2 = NULL;
22231908 39) continue;
22231908 42) if (!(ch & 0x80)) {
22231908 44) if (ch == '&')
22231908 45) fputs("&amp;", stdout);
22231908 46) else if (ch == '\'')
22231908 47) fputs("&apos;", stdout);
22231908 48) else if (ch == '"')
22231908 49) fputs("&quot;", stdout);
22231908 50) else if (ch == '<')
22231908 51) fputs("&lt;", stdout);
22231908 52) else if (ch == '>')
22231908 53) fputs("&gt;", stdout);
22231908 54) else if (ch >= 0x20)
22231908 55) fputc(ch, stdout);
22231908 56) else if (ch == 0x09 || ch == 0x0a || ch == 0x0d)
22231908 57) fprintf(stdout, "&#x%02x;", ch);
22231908 59) fputs(utf8_replace_character, stdout);
22231908 60) } else if ((ch & 0xe0) == 0xc0) {
22231908 62) tmp[0] = ch;
22231908 63) remaining = 1;
22231908 64) tmp2 = tmp + 1;
22231908 65) } else if ((ch & 0xf0) == 0xe0) {
22231908 67) tmp[0] = ch;
22231908 68) remaining = 2;
22231908 69) tmp2 = tmp + 1;
22231908 70) } else if ((ch & 0xf8) == 0xf0) {
22231908 72) tmp[0] = ch;
22231908 73) remaining = 3;
22231908 74) tmp2 = tmp + 1;
22231908 76) fputs(utf8_replace_character, stdout);
22231908 77) }

utf8.c
aab2a1ae 568) bom_str = utf16_be_bom;
aab2a1ae 569) bom_len = sizeof(utf16_be_bom);
aab2a1ae 570) out_encoding = "UTF-16BE";

wrapper.c
e3b1e3bd 701) die_errno(_("could not stat %s"), filename);

Commits introducting uncovered code:
David Turner	d1dd94b3 Do not print 'dangling' for cat-file in case of ambiguity
Derrick Stolee	4f6d26b1 list-objects: consume sparse tree walk
Derrick Stolee	f1f5de44 revision: add mark_tree_uninteresting_sparse
Derrick Stolee	d5d2e935 revision: implement sparse algorithm
Elijah Newren	899b49c4 git-rebase, sequencer: extend --quiet option for the interactive machinery
Jeff King	ba285a71 test-date: drop unused parameter to getnanos()
Jeff King	00a7760e sha1-file: modernize loose header/stream functions
Jeff King	76011357 sha1-file: prefer "loose object file" to "sha1 file" in messages
Jeff King	2c319886 sha1-file: avoid "sha1 file" for generic use in messages
Jeff King	514c5fdd sha1-file: modernize loose object file functions
Jeff King	01f8d594 prefer "hash mismatch" to "sha1 mismatch"
Johannes Schindelin	c5233708 rebase: move `reset_head()` into a better spot
Johannes Schindelin	22231908 tests: optionally write results as JUnit-style .xml
Johannes Schindelin	af9912ef tests: include detailed trace logs with --write-junit-xml upon failure
Johannes Schindelin	5868bd86 tests: avoid calling Perl just to determine file sizes
Johannes Schindelin	b819f1d2 ci: parallelize testing on Windows
Johannes Schindelin	4419de91 test-date: add a subcommand to measure times in shell scripts
Johannes Schindelin	21853626 built-in rebase: call `git am` directly
Linus Torvalds	acdd3776 Add 'human' date format
Nguyễn Thái Ngọc Duy	0d6caa2d merge-recursive.c: remove implicit dependency on the_index
Nguyễn Thái Ngọc Duy	3a95f31d repository.c: replace hold_locked_index() with repo_hold_locked_index()
Nguyễn Thái Ngọc Duy	e1ff0a32 read-cache.c: kill read_index()
Pranit Bauva	5e82c3dd bisect--helper: `bisect_reset` shell function in C
Pranit Bauva	450ebb73 bisect--helper: `get_terms` & `bisect_terms` shell function in C
Pranit Bauva	129a6cf3 bisect--helper: `bisect_next_check` shell function in C
Pranit Bauva	06f5608c bisect--helper: `bisect_start` shell function partially in C
Pranit Bauva	4fbdbd5b bisect--helper: `check_and_set_terms` shell function in C
Pranit Bauva	0f30233a bisect--helper: `bisect_write` shell function in C
Pranit Bauva	e3b1e3bd wrapper: move is_empty_file() and rename it as is_empty_or_missing_file()
Shahzad Lone	33de80b1 various: tighten constness of some local variables
Stephen P. Smith	2fd7c229 Replace the proposed 'auto' mode with 'auto:'
Torsten Bögershausen	aab2a1ae Support working-tree-encoding "UTF-16LE-BOM"


